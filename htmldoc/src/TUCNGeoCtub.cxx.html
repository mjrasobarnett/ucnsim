<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<!--                                             -->
<!-- Author: ROOT team (rootdev@pcroot.cern.ch)  -->
<!--                                             -->
<!--   Date: Thu Jun 18 00:10:41 2009            -->
<!--                                             -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
<title>TUCNGeoCtub - source file</title>
<meta name="rating" content="General" />
<meta name="objecttype" content="Manual" />
<meta name="keywords" content="software development, oo, object oriented, unix, x11, windows, c++, html, rene brun, fons rademakers, cern" />
<meta name="description" content="ROOT - An Object Oriented Framework For Large Scale Data Analysis." />
<link rel="stylesheet" type="text/css" href="../ROOT.css" id="ROOTstyle" />
<script type="text/javascript" src="../ROOT.js"></script>
</head>
<body  onload="javascript:SetValuesFromCookie();">
<pre class="code">
<span class="comment">// <a href="../TUCNGeoBBox.html">TUCNGeoBBox</a></span>
<span class="comment">// Author: Matthew Raso-Barnett  22/05/2009</span>


<span class="cpp">#include "Riostream.h"</span>

<span class="cpp">#include "TGeoManager.h"</span>
<span class="cpp">#include "TGeoVolume.h"</span>
<span class="cpp">#include "TVirtualGeoPainter.h"</span>
<span class="cpp">#include "TVirtualPad.h"</span>
<span class="cpp">#include "TBuffer3D.h"</span>
<span class="cpp">#include "TBuffer3DTypes.h"</span>
<span class="cpp">#include "TMath.h"</span>

<span class="cpp">#include "<a href="../TUCNGeoTube.h">TUCNGeoTube.h</a>"</span>

ClassImp(<a href="../TUCNGeoTube.html">TUCNGeoTube</a>)

<span class="comment">//_____________________________________________________________________________</span>
<a href="../TUCNGeoTube.html">TUCNGeoTube</a>::<a href="../TUCNGeoTube.html#TUCNGeoTube:TUCNGeoTube" title="TUCNGeoTube TUCNGeoTube::TUCNGeoTube() or overloads">TUCNGeoTube</a>()
{
<span class="comment">// Default constructor</span>
   <a href="../#TObject:Info" title="void TObject::Info(const char* method,const char* msgfmt)">Info</a>(<span class="string">"TUCNGeoTube"</span>, <span class="string">"Default Constructor"</span>);
	<a href="../#TGeoShape:SetShapeBit" title="void TGeoShape::SetShapeBit(UInt_t f,Bool_t set) or overloads">SetShapeBit</a>(TGeoShape::kGeoTube);
   fRmin = 0.0;
   fRmax = 0.0;
   fDz   = 0.0;
}


<span class="comment">//_____________________________________________________________________________</span>
<a href="../TUCNGeoTube.html">TUCNGeoTube</a>::<a href="../TUCNGeoTube.html#TUCNGeoTube:TUCNGeoTube" title="TUCNGeoTube TUCNGeoTube::TUCNGeoTube() or overloads">TUCNGeoTube</a>(<a href="../ListOfTypes.html#Double_t">Double_t</a> rmin, <a href="../ListOfTypes.html#Double_t">Double_t</a> rmax, <a href="../ListOfTypes.html#Double_t">Double_t</a> dz)
         	:<a href="../TUCNGeoBBox.html">TUCNGeoBBox</a>(0, 0, 0)
{
<span class="comment">// Default constructor specifying minimum and maximum radius</span>
   <a href="../#TObject:Info" title="void TObject::Info(const char* method,const char* msgfmt)">Info</a>(<span class="string">"TUCNGeoTube"</span>, <span class="string">"Constructor"</span>);
   <a href="../#TGeoShape:SetShapeBit" title="void TGeoShape::SetShapeBit(UInt_t f,Bool_t set) or overloads">SetShapeBit</a>(TGeoShape::kGeoTube);
   <a href="../TUCNGeoTube.html#TUCNGeoTube:SetTubeDimensions" title="void TUCNGeoTube::SetTubeDimensions(Double_t rmin,Double_t rmax,Double_t dz)">SetTubeDimensions</a>(rmin, rmax, dz);
   <span class="keyword">if</span> ((fDz&lt;0) || (fRmin&lt;0) || (fRmax&lt;0)) {
      <a href="../#TGeoShape:SetShapeBit" title="void TGeoShape::SetShapeBit(UInt_t f,Bool_t set) or overloads">SetShapeBit</a>(kGeoRunTimeShape);
<span class="comment">//      if (fRmax&lt;=fRmin) <a href="../#TGeoShape:SetShapeBit" title="void TGeoShape::SetShapeBit(UInt_t f,Bool_t set) or overloads">SetShapeBit</a>(kGeoInvalidShape);</span>
<span class="comment">//      printf(<span class="string">"tube : dz=%f rmin=%f rmax=%f\n"</span>, dz, rmin, rmax);</span>
   }
   <a href="../TUCNGeoCtub.html#TUCNGeoCtub:ComputeBBox" title="void TUCNGeoCtub::ComputeBBox()">ComputeBBox</a>();
}
<span class="comment">//_____________________________________________________________________________</span>
<a href="../TUCNGeoTube.html">TUCNGeoTube</a>::<a href="../TUCNGeoTube.html#TUCNGeoTube:TUCNGeoTube" title="TUCNGeoTube TUCNGeoTube::TUCNGeoTube() or overloads">TUCNGeoTube</a>(<span class="keyword">const</span> <span class="keyword">char</span> *name, <a href="../ListOfTypes.html#Double_t">Double_t</a> rmin, <a href="../ListOfTypes.html#Double_t">Double_t</a> rmax, <a href="../ListOfTypes.html#Double_t">Double_t</a> dz)
            :<a href="../TUCNGeoBBox.html">TUCNGeoBBox</a>(name, 0, 0, 0)
{
<span class="comment">// Default constructor specifying minimum and maximum radius</span>
   <a href="../#TObject:Info" title="void TObject::Info(const char* method,const char* msgfmt)">Info</a>(<span class="string">"TUCNGeoTube"</span>, <span class="string">"Constructor"</span>);
   <a href="../#TGeoShape:SetShapeBit" title="void TGeoShape::SetShapeBit(UInt_t f,Bool_t set) or overloads">SetShapeBit</a>(TGeoShape::kGeoTube);
   <a href="../TUCNGeoTube.html#TUCNGeoTube:SetTubeDimensions" title="void TUCNGeoTube::SetTubeDimensions(Double_t rmin,Double_t rmax,Double_t dz)">SetTubeDimensions</a>(rmin, rmax, dz);
   <span class="keyword">if</span> ((fDz&lt;0) || (fRmin&lt;0) || (fRmax&lt;0)) {
      <a href="../#TGeoShape:SetShapeBit" title="void TGeoShape::SetShapeBit(UInt_t f,Bool_t set) or overloads">SetShapeBit</a>(kGeoRunTimeShape);
<span class="comment">//      if (fRmax&lt;=fRmin) <a href="../#TGeoShape:SetShapeBit" title="void TGeoShape::SetShapeBit(UInt_t f,Bool_t set) or overloads">SetShapeBit</a>(kGeoInvalidShape);</span>
<span class="comment">//      printf(<span class="string">"tube : dz=%f rmin=%f rmax=%f\n"</span>, dz, rmin, rmax);</span>
   }
   <a href="../TUCNGeoCtub.html#TUCNGeoCtub:ComputeBBox" title="void TUCNGeoCtub::ComputeBBox()">ComputeBBox</a>();
}

<span class="comment">//_____________________________________________________________________________</span>
<a href="../TUCNGeoTube.html">TUCNGeoTube</a>::<a href="../TUCNGeoTube.html#TUCNGeoTube:TUCNGeoTube" title="TUCNGeoTube TUCNGeoTube::TUCNGeoTube() or overloads">TUCNGeoTube</a>(<a href="../ListOfTypes.html#Double_t">Double_t</a> *param)
         	:<a href="../TUCNGeoBBox.html">TUCNGeoBBox</a>(0, 0, 0)
{
<span class="comment">// Default constructor specifying minimum and maximum radius</span>
<span class="comment">// param[0] = Rmin</span>
<span class="comment">// param[1] = Rmax</span>
<span class="comment">// param[2] = dz</span>
   <a href="../#TObject:Info" title="void TObject::Info(const char* method,const char* msgfmt)">Info</a>(<span class="string">"TUCNGeoTube"</span>, <span class="string">"Constructor"</span>);
   <a href="../#TGeoShape:SetShapeBit" title="void TGeoShape::SetShapeBit(UInt_t f,Bool_t set) or overloads">SetShapeBit</a>(TGeoShape::kGeoTube);
   <a href="../TUCNGeoCtub.html#TUCNGeoCtub:SetDimensions" title="void TUCNGeoCtub::SetDimensions(Double_t* param)">SetDimensions</a>(param);
   <span class="keyword">if</span> ((fDz&lt;0) || (fRmin&lt;0) || (fRmax&lt;0)) <a href="../#TGeoShape:SetShapeBit" title="void TGeoShape::SetShapeBit(UInt_t f,Bool_t set) or overloads">SetShapeBit</a>(kGeoRunTimeShape);
   <a href="../TUCNGeoCtub.html#TUCNGeoCtub:ComputeBBox" title="void TUCNGeoCtub::ComputeBBox()">ComputeBBox</a>();
}

<span class="comment">//_____________________________________________________________________________</span>
<a href="../TUCNGeoTube.html">TUCNGeoTube</a>::<a href="../TUCNGeoTube.html#TUCNGeoTube:_TUCNGeoTube" title="void TUCNGeoTube::~TUCNGeoTube()">~TUCNGeoTube</a>()
{
<span class="comment">// destructor</span>
   <a href="../#TObject:Info" title="void TObject::Info(const char* method,const char* msgfmt)">Info</a>(<span class="string">"TUCNGeoTube"</span>, <span class="string">"Destructor"</span>);
}

<span class="comment">//_____________________________________________________________________________</span>
<a href="../ListOfTypes.html#Double_t">Double_t</a> <a href="../TUCNGeoTube.html">TUCNGeoTube</a>::<a href="../TUCNGeoTube.html#TUCNGeoTube:Capacity" title="Double_t TUCNGeoTube::Capacity() or overloads">Capacity</a>() <span class="keyword">const</span>
{
<span class="comment">// Computes capacity of the shape in [length^3]</span>
   <span class="keyword">return</span> <a href="../TUCNGeoTube.html">TUCNGeoTube</a>::<a href="../TUCNGeoTube.html#TUCNGeoTube:Capacity" title="Double_t TUCNGeoTube::Capacity() or overloads">Capacity</a>(fRmin,fRmax, fDz);
}   

<span class="comment">//_____________________________________________________________________________</span>
<a href="../ListOfTypes.html#Double_t">Double_t</a> <a href="../TUCNGeoTube.html">TUCNGeoTube</a>::<a href="../TUCNGeoTube.html#TUCNGeoTube:Capacity" title="Double_t TUCNGeoTube::Capacity() or overloads">Capacity</a>(<a href="../ListOfTypes.html#Double_t">Double_t</a> rmin, <a href="../ListOfTypes.html#Double_t">Double_t</a> rmax, <a href="../ListOfTypes.html#Double_t">Double_t</a> dz)
{
<span class="comment">// Computes capacity of the shape in [length^3]</span>
   <a href="../ListOfTypes.html#Double_t">Double_t</a> capacity = 2.*TMath::Pi()*(rmax*rmax-rmin*rmin)*dz;
   <span class="keyword">return</span> capacity;
}   

<span class="comment">//_____________________________________________________________________________</span>
<span class="keyword">void</span> <a href="../TUCNGeoTube.html">TUCNGeoTube</a>::<a href="../TUCNGeoTube.html#TUCNGeoTube:ComputeBBox" title="void TUCNGeoTube::ComputeBBox()">ComputeBBox</a>()
{
<span class="comment">// compute bounding box of the tube</span>
   fDX = fDY = fRmax;
   fDZ = fDz;
}

<span class="comment">//_____________________________________________________________________________</span>
<span class="keyword">void</span> <a href="../TUCNGeoTube.html">TUCNGeoTube</a>::<a href="../TUCNGeoTube.html#TUCNGeoTube:ComputeNormal" title="void TUCNGeoTube::ComputeNormal(Double_t* point,Double_t* dir,Double_t* norm)">ComputeNormal</a>(<a href="../ListOfTypes.html#Double_t">Double_t</a> *point, <a href="../ListOfTypes.html#Double_t">Double_t</a> *dir, <a href="../ListOfTypes.html#Double_t">Double_t</a> *norm)
{
<span class="comment">// Compute normal to closest surface from POINT.</span>
   <a href="../ListOfTypes.html#Double_t">Double_t</a> saf[3];
   <a href="../ListOfTypes.html#Double_t">Double_t</a> rsq = point[0]*point[0]+point[1]*point[1];
   <a href="../ListOfTypes.html#Double_t">Double_t</a> r = TMath::Sqrt(rsq);
   saf[0] = TMath::Abs(fDz-TMath::Abs(point[2]));
   saf[1] = (fRmin&gt;1E-10)?TMath::Abs(r-fRmin):TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
   saf[2] = TMath::Abs(fRmax-r);
   <a href="../ListOfTypes.html#Int_t">Int_t</a> i = TMath::LocMin(3,saf);
   <span class="keyword">if</span> (i==0) {
      norm[0] = norm[1] = 0.;
      norm[2] = TMath::Sign(1.,dir[2]);
      <span class="keyword">return</span>;
   }
   norm[2] = 0;
   <a href="../ListOfTypes.html#Double_t">Double_t</a> phi = TMath::ATan2(point[1], point[0]);
   norm[0] = TMath::Cos(phi);
   norm[1] = TMath::Sin(phi);
   <span class="keyword">if</span> (norm[0]*dir[0]+norm[1]*dir[1]&lt;0) {
      norm[0] = -norm[0];
      norm[1] = -norm[1];
   }
}

<span class="comment">//_____________________________________________________________________________</span>
<span class="keyword">void</span> <a href="../TUCNGeoTube.html">TUCNGeoTube</a>::<a href="../TUCNGeoTube.html#TUCNGeoTube:ComputeNormalS" title="void TUCNGeoTube::ComputeNormalS(Double_t* point,Double_t* dir,Double_t* norm,Double_t rmin,Double_t rmax,Double_t dz)">ComputeNormalS</a>(<a href="../ListOfTypes.html#Double_t">Double_t</a> *point, <a href="../ListOfTypes.html#Double_t">Double_t</a> *dir, <a href="../ListOfTypes.html#Double_t">Double_t</a> *norm,
                              <a href="../ListOfTypes.html#Double_t">Double_t</a> <span class="comment">/*rmin*/</span>, <a href="../ListOfTypes.html#Double_t">Double_t</a> <span class="comment">/*rmax*/</span>, <a href="../ListOfTypes.html#Double_t">Double_t</a> <span class="comment">/*dz*/</span>)
{
<span class="comment">// Compute normal to closest surface from POINT.</span>
   norm[2] = 0;
   <a href="../ListOfTypes.html#Double_t">Double_t</a> phi = TMath::ATan2(point[1], point[0]);
   norm[0] = TMath::Cos(phi);
   norm[1] = TMath::Sin(phi);
   <span class="keyword">if</span> (norm[0]*dir[0]+norm[1]*dir[1]&lt;0) {
      norm[0] = -norm[0];
      norm[1] = -norm[1];
   }
}

<span class="comment">//_____________________________________________________________________________</span>
<a href="../ListOfTypes.html#Bool_t">Bool_t</a> <a href="../TUCNGeoTube.html">TUCNGeoTube</a>::<a href="../TUCNGeoTube.html#TUCNGeoTube:Contains" title="Bool_t TUCNGeoTube::Contains(Double_t* point)">Contains</a>(<a href="../ListOfTypes.html#Double_t">Double_t</a> *point) <span class="keyword">const</span>
{
<span class="comment">// test if point is inside this tube</span>
   <span class="keyword">if</span> (TMath::Abs(point[2]) &gt; fDz) <span class="keyword">return</span> <a href="../ListOfTypes.html#Bool_t">kFALSE</a>;
   <a href="../ListOfTypes.html#Double_t">Double_t</a> r2 = point[0]*point[0]+point[1]*point[1];
   <span class="keyword">if</span> ((r2&lt;fRmin*fRmin) || (r2&gt;fRmax*fRmax)) <span class="keyword">return</span> <a href="../ListOfTypes.html#Bool_t">kFALSE</a>;
   <span class="keyword">return</span> <a href="../ListOfTypes.html#Bool_t">kTRUE</a>;
}

<span class="comment">//_____________________________________________________________________________</span>
<a href="../ListOfTypes.html#Int_t">Int_t</a> <a href="../TUCNGeoTube.html">TUCNGeoTube</a>::<a href="../TUCNGeoTube.html#TUCNGeoTube:DistancetoPrimitive" title="Int_t TUCNGeoTube::DistancetoPrimitive(Int_t px,Int_t py)">DistancetoPrimitive</a>(<a href="../ListOfTypes.html#Int_t">Int_t</a> px, <a href="../ListOfTypes.html#Int_t">Int_t</a> py)
{
<span class="comment">// compute closest distance from point px,py to each corner</span>
   <a href="../ListOfTypes.html#Int_t">Int_t</a> n = gGeoManager-&gt;GetNsegments();
   <a href="../ListOfTypes.html#Int_t">Int_t</a> numPoints = 4*n;
   <span class="keyword">if</span> (!<a href="../TUCNGeoTube.html#TUCNGeoTube:HasRmin" title="Bool_t TUCNGeoTube::HasRmin()">HasRmin</a>()) numPoints = 2*(n+1);
   <span class="keyword">return</span> <a href="../#TGeoShape:ShapeDistancetoPrimitive" title="Int_t TGeoShape::ShapeDistancetoPrimitive(Int_t numpoints,Int_t px,Int_t py)">ShapeDistancetoPrimitive</a>(numPoints, px, py);
}

<span class="comment">//_____________________________________________________________________________</span>
<a href="../ListOfTypes.html#Double_t">Double_t</a> <a href="../TUCNGeoTube.html">TUCNGeoTube</a>::<a href="../TUCNGeoTube.html#TUCNGeoTube:DistFromInsideS" title="Double_t TUCNGeoTube::DistFromInsideS(Double_t* point,Double_t* dir,Double_t rmin,Double_t rmax,Double_t dz)">DistFromInsideS</a>(<a href="../ListOfTypes.html#Double_t">Double_t</a> *point, <a href="../ListOfTypes.html#Double_t">Double_t</a> *dir, <a href="../ListOfTypes.html#Double_t">Double_t</a> rmin, <a href="../ListOfTypes.html#Double_t">Double_t</a> rmax, <a href="../ListOfTypes.html#Double_t">Double_t</a> dz)
{
<span class="comment">// Compute distance from inside point to surface of the tube (static)</span>
<span class="comment">// Boundary safe algorithm.</span>
   <span class="comment">// compute distance to surface</span>
   <span class="comment">// Do Z</span>
   <a href="../ListOfTypes.html#Double_t">Double_t</a> sz = TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
   <span class="keyword">if</span> (dir[2]) {
      sz = (TMath::Sign(dz, dir[2])-point[2])/dir[2];
      <span class="keyword">if</span> (sz&lt;=0) <span class="keyword">return</span> 0.0;
   }
   <span class="comment">// Do R</span>
   <a href="../ListOfTypes.html#Double_t">Double_t</a> nsq=dir[0]*dir[0]+dir[1]*dir[1];
   <span class="keyword">if</span> (TMath::Abs(nsq)&lt;TGeoShape::<a href="../#TGeoShape:Tolerance" title="Double_t TGeoShape::Tolerance()">Tolerance</a>()) <span class="keyword">return</span> sz;
   <a href="../ListOfTypes.html#Double_t">Double_t</a> rsq=point[0]*point[0]+point[1]*point[1];
   <a href="../ListOfTypes.html#Double_t">Double_t</a> rdotn=point[0]*dir[0]+point[1]*dir[1];
   <a href="../ListOfTypes.html#Double_t">Double_t</a> b,d;
   <a href="../ListOfTypes.html#Double_t">Double_t</a> sr = TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
   <span class="comment">// inner cylinder</span>
   <span class="keyword">if</span> (rmin&gt;0) {
      <span class="comment">// Protection in case point is actually outside the tube</span>
      <span class="keyword">if</span> (rsq &lt;= rmin*rmin+TGeoShape::<a href="../#TGeoShape:Tolerance" title="Double_t TGeoShape::Tolerance()">Tolerance</a>()) {
         <span class="keyword">if</span> (rdotn&lt;0) <span class="keyword">return</span> 0.0;
      } <span class="keyword">else</span> {
         <span class="keyword">if</span> (rdotn&lt;0) {
            <a href="../TUCNGeoTube.html#TUCNGeoTube:DistToTube" title="void TUCNGeoTube::DistToTube(Double_t rsq,Double_t nsq,Double_t rdotn,Double_t radius,Double_t&amp; b,Double_t&amp; delta)">DistToTube</a>(rsq,nsq,rdotn,rmin,b,d);
            <span class="keyword">if</span> (d&gt;0) {
               sr=-b-d;
               <span class="keyword">if</span> (sr&gt;0) <span class="keyword">return</span> TMath::Min(sz,sr);
            }
         }
      }
   }
   <span class="comment">// outer cylinder</span>
   <span class="keyword">if</span> (rsq &gt;= rmax*rmax-TGeoShape::<a href="../#TGeoShape:Tolerance" title="Double_t TGeoShape::Tolerance()">Tolerance</a>()) {
      <span class="keyword">if</span> (rdotn&gt;=0) <span class="keyword">return</span> 0.0;
   }
   <a href="../TUCNGeoTube.html#TUCNGeoTube:DistToTube" title="void TUCNGeoTube::DistToTube(Double_t rsq,Double_t nsq,Double_t rdotn,Double_t radius,Double_t&amp; b,Double_t&amp; delta)">DistToTube</a>(rsq,nsq,rdotn,rmax,b,d);
   <span class="keyword">if</span> (d&gt;0) {
      sr=-b+d;
      <span class="keyword">if</span> (sr&gt;0) <span class="keyword">return</span> TMath::Min(sz,sr);
   }
   <span class="keyword">return</span> 0.;
}

<span class="comment">//_____________________________________________________________________________</span>
<a href="../ListOfTypes.html#Double_t">Double_t</a> <a href="../TUCNGeoTube.html">TUCNGeoTube</a>::<a href="../TUCNGeoTube.html#TUCNGeoTube:DistFromInside" title="Double_t TUCNGeoTube::DistFromInside(Double_t* point,Double_t* dir,Int_t iact=1,Double_t step=TGeoShape::Big(),Double_t* safe=0)">DistFromInside</a>(<a href="../ListOfTypes.html#Double_t">Double_t</a> *point, <a href="../ListOfTypes.html#Double_t">Double_t</a> *dir, <a href="../ListOfTypes.html#Int_t">Int_t</a> iact, <a href="../ListOfTypes.html#Double_t">Double_t</a> step, <a href="../ListOfTypes.html#Double_t">Double_t</a> *safe) <span class="keyword">const</span>
{
<span class="comment">// Compute distance from inside point to surface of the tube</span>
<span class="comment">// Boundary safe algorithm.</span>
   <span class="keyword">if</span> (iact&lt;3 &amp;&amp; safe) {
      *safe = <a href="../TUCNGeoCtub.html#TUCNGeoCtub:Safety" title="Double_t TUCNGeoCtub::Safety(Double_t* point,Bool_t in=kTRUE)">Safety</a>(point, <a href="../ListOfTypes.html#Bool_t">kTRUE</a>);
      <span class="keyword">if</span> (iact==0) <span class="keyword">return</span> TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
      <span class="keyword">if</span> ((iact==1) &amp;&amp; (*safe&gt;step)) <span class="keyword">return</span> TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
   }
   <span class="comment">// compute distance to surface</span>
   <span class="keyword">return</span> <a href="../TUCNGeoTubeSeg.html#TUCNGeoTubeSeg:DistFromInsideS" title="Double_t TUCNGeoTubeSeg::DistFromInsideS(Double_t* point,Double_t* dir,Double_t rmin,Double_t rmax,Double_t dz,Double_t c1,Double_t s1,Double_t c2,Double_t s2,Double_t cm,Double_t sm,Double_t cdfi)">DistFromInsideS</a>(point, dir, fRmin, fRmax, fDz);
}

<span class="comment">//_____________________________________________________________________________</span>
<a href="../ListOfTypes.html#Double_t">Double_t</a> <a href="../TUCNGeoTube.html">TUCNGeoTube</a>::<a href="../TUCNGeoTube.html#TUCNGeoTube:DistFromOutsideS" title="Double_t TUCNGeoTube::DistFromOutsideS(Double_t* point,Double_t* dir,Double_t rmin,Double_t rmax,Double_t dz)">DistFromOutsideS</a>(<a href="../ListOfTypes.html#Double_t">Double_t</a> *point, <a href="../ListOfTypes.html#Double_t">Double_t</a> *dir, <a href="../ListOfTypes.html#Double_t">Double_t</a> rmin, <a href="../ListOfTypes.html#Double_t">Double_t</a> rmax, <a href="../ListOfTypes.html#Double_t">Double_t</a> dz)
{
<span class="comment">// Static method to compute distance from outside point to a tube with given parameters</span>
<span class="comment">// Boundary safe algorithm.</span>
   <span class="comment">// check Z planes</span>
   <a href="../ListOfTypes.html#Double_t">Double_t</a> xi,yi,zi;
   <a href="../ListOfTypes.html#Double_t">Double_t</a> rmaxsq = rmax*rmax;
   <a href="../ListOfTypes.html#Double_t">Double_t</a> rminsq = rmin*rmin;
   zi = dz - TMath::Abs(point[2]);
   <a href="../ListOfTypes.html#Double_t">Double_t</a> s = TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
   <a href="../ListOfTypes.html#Bool_t">Bool_t</a> in = <a href="../ListOfTypes.html#Bool_t">kFALSE</a>;
   <a href="../ListOfTypes.html#Bool_t">Bool_t</a> inz = (zi&lt;0)?<a href="../ListOfTypes.html#Bool_t">kFALSE</a>:<a href="../ListOfTypes.html#Bool_t">kTRUE</a>;
   <span class="keyword">if</span> (!inz) {
      <span class="keyword">if</span> (point[2]*dir[2]&gt;=0) <span class="keyword">return</span> TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
      s  = -zi/TMath::Abs(dir[2]);
      xi = point[0]+s*dir[0];
      yi = point[1]+s*dir[1];
      <a href="../ListOfTypes.html#Double_t">Double_t</a> r2=xi*xi+yi*yi;
      <span class="keyword">if</span> ((rminsq&lt;=r2) &amp;&amp; (r2&lt;=rmaxsq)) <span class="keyword">return</span> s;
   }

   <a href="../ListOfTypes.html#Double_t">Double_t</a> rsq = point[0]*point[0]+point[1]*point[1];
   <span class="comment">// check outer cyl. surface</span>
   <a href="../ListOfTypes.html#Double_t">Double_t</a> nsq=dir[0]*dir[0]+dir[1]*dir[1];
   <a href="../ListOfTypes.html#Double_t">Double_t</a> rdotn=point[0]*dir[0]+point[1]*dir[1];
   <a href="../ListOfTypes.html#Double_t">Double_t</a> b,d;
   <a href="../ListOfTypes.html#Bool_t">Bool_t</a> inrmax = <a href="../ListOfTypes.html#Bool_t">kFALSE</a>;
   <a href="../ListOfTypes.html#Bool_t">Bool_t</a> inrmin = <a href="../ListOfTypes.html#Bool_t">kFALSE</a>;
   <span class="keyword">if</span> (rsq&lt;=rmaxsq+TGeoShape::<a href="../#TGeoShape:Tolerance" title="Double_t TGeoShape::Tolerance()">Tolerance</a>()) inrmax = <a href="../ListOfTypes.html#Bool_t">kTRUE</a>;
   <span class="keyword">if</span> (rsq&gt;=rminsq-TGeoShape::<a href="../#TGeoShape:Tolerance" title="Double_t TGeoShape::Tolerance()">Tolerance</a>()) inrmin = <a href="../ListOfTypes.html#Bool_t">kTRUE</a>;
   in = inz &amp; inrmin &amp; inrmax;
   <span class="comment">// If inside, we are most likely on a boundary within machine precision.</span>
   <span class="keyword">if</span> (in) {
      <a href="../ListOfTypes.html#Bool_t">Bool_t</a> checkout = <a href="../ListOfTypes.html#Bool_t">kFALSE</a>;
      <a href="../ListOfTypes.html#Double_t">Double_t</a> r = TMath::Sqrt(rsq);
      <span class="keyword">if</span> (zi&lt;rmax-r) {
         <span class="keyword">if</span> ((rmin==0) || (zi&lt;r-rmin)) {
            <span class="keyword">if</span> (point[2]*dir[2]&lt;0) <span class="keyword">return</span> 0.0;
            <span class="keyword">return</span> TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
         }
      }
      <span class="keyword">if</span> ((rmaxsq-rsq) &lt; (rsq-rminsq)) checkout = <a href="../ListOfTypes.html#Bool_t">kTRUE</a>;
      <span class="keyword">if</span> (checkout) {
         <span class="keyword">if</span> (rdotn&gt;=0) <span class="keyword">return</span> TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
         <span class="keyword">return</span> 0.0;
      }
      <span class="keyword">if</span> (rmin==0) <span class="keyword">return</span> 0.0;
      <span class="keyword">if</span> (rdotn&gt;=0) <span class="keyword">return</span> 0.0;
      <span class="comment">// Ray exiting rmin -&gt; check (+) solution for inner tube</span>
      <span class="keyword">if</span> (TMath::Abs(nsq)&lt;TGeoShape::<a href="../#TGeoShape:Tolerance" title="Double_t TGeoShape::Tolerance()">Tolerance</a>()) <span class="keyword">return</span> TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
      <a href="../TUCNGeoTube.html#TUCNGeoTube:DistToTube" title="void TUCNGeoTube::DistToTube(Double_t rsq,Double_t nsq,Double_t rdotn,Double_t radius,Double_t&amp; b,Double_t&amp; delta)">DistToTube</a>(rsq, nsq, rdotn, rmin, b, d);
      <span class="keyword">if</span> (d&gt;0) {
         s=-b+d;
         <span class="keyword">if</span> (s&gt;0) {
            zi=point[2]+s*dir[2];
            <span class="keyword">if</span> (TMath::Abs(zi)&lt;=dz) <span class="keyword">return</span> s;
         }
      }
      <span class="keyword">return</span> TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
   }
   <span class="comment">// Check outer cylinder (only r&gt;rmax has to be considered)</span>
   <span class="keyword">if</span> (TMath::Abs(nsq)&lt;TGeoShape::<a href="../#TGeoShape:Tolerance" title="Double_t TGeoShape::Tolerance()">Tolerance</a>()) <span class="keyword">return</span> TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
   <span class="keyword">if</span> (!inrmax) {
      <a href="../TUCNGeoTube.html#TUCNGeoTube:DistToTube" title="void TUCNGeoTube::DistToTube(Double_t rsq,Double_t nsq,Double_t rdotn,Double_t radius,Double_t&amp; b,Double_t&amp; delta)">DistToTube</a>(rsq, nsq, rdotn, rmax, b, d);
      <span class="keyword">if</span> (d&gt;0) {
         s=-b-d;
         <span class="keyword">if</span> (s&gt;0) {
            zi=point[2]+s*dir[2];
            <span class="keyword">if</span> (TMath::Abs(zi)&lt;=dz) <span class="keyword">return</span> s;
         }
      }
   }
   <span class="comment">// check inner cylinder</span>
   <span class="keyword">if</span> (rmin&gt;0) {
      <a href="../TUCNGeoTube.html#TUCNGeoTube:DistToTube" title="void TUCNGeoTube::DistToTube(Double_t rsq,Double_t nsq,Double_t rdotn,Double_t radius,Double_t&amp; b,Double_t&amp; delta)">DistToTube</a>(rsq, nsq, rdotn, rmin, b, d);
      <span class="keyword">if</span> (d&gt;0) {
         s=-b+d;
         <span class="keyword">if</span> (s&gt;0) {
            zi=point[2]+s*dir[2];
            <span class="keyword">if</span> (TMath::Abs(zi)&lt;=dz) <span class="keyword">return</span> s;
         }
      }
   }
   <span class="keyword">return</span> TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
}

<span class="comment">//_____________________________________________________________________________</span>
<a href="../ListOfTypes.html#Double_t">Double_t</a> <a href="../TUCNGeoTube.html">TUCNGeoTube</a>::<a href="../TUCNGeoTube.html#TUCNGeoTube:DistFromOutside" title="Double_t TUCNGeoTube::DistFromOutside(Double_t* point,Double_t* dir,Int_t iact=1,Double_t step=TGeoShape::Big(),Double_t* safe=0)">DistFromOutside</a>(<a href="../ListOfTypes.html#Double_t">Double_t</a> *point, <a href="../ListOfTypes.html#Double_t">Double_t</a> *dir, <a href="../ListOfTypes.html#Int_t">Int_t</a> iact, <a href="../ListOfTypes.html#Double_t">Double_t</a> step, <a href="../ListOfTypes.html#Double_t">Double_t</a> *safe) <span class="keyword">const</span>
{
<span class="comment">// Compute distance from outside point to surface of the tube and safe distance</span>
<span class="comment">// Boundary safe algorithm.</span>
   <span class="comment">// fist localize point w.r.t tube</span>
   <span class="keyword">if</span> (iact&lt;3 &amp;&amp; safe) {
      *safe = <a href="../TUCNGeoCtub.html#TUCNGeoCtub:Safety" title="Double_t TUCNGeoCtub::Safety(Double_t* point,Bool_t in=kTRUE)">Safety</a>(point, <a href="../ListOfTypes.html#Bool_t">kFALSE</a>);
      <span class="keyword">if</span> (iact==0) <span class="keyword">return</span> TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
      <span class="keyword">if</span> ((iact==1) &amp;&amp; (step&lt;=*safe)) <span class="keyword">return</span> TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
   }
<span class="comment">// Check if the bounding box is crossed within the requested distance</span>
   <a href="../ListOfTypes.html#Double_t">Double_t</a> sdist = <a href="../TUCNGeoBBox.html">TUCNGeoBBox</a>::<a href="../#TGeoBBox:DistFromOutside" title="Double_t TGeoBBox::DistFromOutside(Double_t* point,Double_t* dir,Int_t iact=1,Double_t step=TGeoShape::Big(),Double_t* safe=0) or overloads">DistFromOutside</a>(point,dir, fDX, fDY, fDZ, fOrigin, step);
   <span class="keyword">if</span> (sdist&gt;=step) <span class="keyword">return</span> TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
   <span class="comment">// find distance to shape</span>
   <span class="keyword">return</span> <a href="../TUCNGeoTubeSeg.html#TUCNGeoTubeSeg:DistFromOutsideS" title="Double_t TUCNGeoTubeSeg::DistFromOutsideS(Double_t* point,Double_t* dir,Double_t rmin,Double_t rmax,Double_t dz,Double_t c1,Double_t s1,Double_t c2,Double_t s2,Double_t cm,Double_t sm,Double_t cdfi)">DistFromOutsideS</a>(point, dir, fRmin, fRmax, fDz);
}

<span class="comment">//_____________________________________________________________________________</span>
<span class="keyword">void</span> <a href="../TUCNGeoTube.html">TUCNGeoTube</a>::<a href="../TUCNGeoTube.html#TUCNGeoTube:DistToTube" title="void TUCNGeoTube::DistToTube(Double_t rsq,Double_t nsq,Double_t rdotn,Double_t radius,Double_t&amp; b,Double_t&amp; delta)">DistToTube</a>(<a href="../ListOfTypes.html#Double_t">Double_t</a> rsq, <a href="../ListOfTypes.html#Double_t">Double_t</a> nsq, <a href="../ListOfTypes.html#Double_t">Double_t</a> rdotn, <a href="../ListOfTypes.html#Double_t">Double_t</a> radius, <a href="../ListOfTypes.html#Double_t">Double_t</a> &amp;b, <a href="../ListOfTypes.html#Double_t">Double_t</a> &amp;delta)
{
<span class="comment">// Static method computing the distance to a tube with given radius, starting from</span>
<span class="comment">// POINT along DIR director cosines. The distance is computed as :</span>
<span class="comment">//    RSQ   = point[0]*point[0]+point[1]*point[1]</span>
<span class="comment">//    NSQ   = dir[0]*dir[0]+dir[1]*dir[1]  ---&gt; should NOT be 0 !!!</span>
<span class="comment">//    RDOTN = point[0]*dir[0]+point[1]*dir[1]</span>
<span class="comment">// The distance can be computed as :</span>
<span class="comment">//    D = -B +/- DELTA</span>
<span class="comment">// where DELTA.GT.0 and D.GT.0</span>

   <a href="../ListOfTypes.html#Double_t">Double_t</a> t1 = 1./nsq;
   <a href="../ListOfTypes.html#Double_t">Double_t</a> t3=rsq-(radius*radius);
   b          = t1*rdotn;
   <a href="../ListOfTypes.html#Double_t">Double_t</a> c =t1*t3;
   delta = b*b-c;
   <span class="keyword">if</span> (delta&gt;0) {
      delta=TMath::Sqrt(delta);
   } <span class="keyword">else</span> {
      delta = -1;
   }
}

<span class="comment">//_____________________________________________________________________________</span>
TGeoVolume *<a href="../TUCNGeoTube.html">TUCNGeoTube</a>::<a href="../TUCNGeoTube.html#TUCNGeoTube:Divide" title="TGeoVolume* TUCNGeoTube::Divide(TGeoVolume* voldiv,const char* divname,Int_t iaxis,Int_t ndiv,Double_t start,Double_t step)">Divide</a>(TGeoVolume *voldiv, <span class="keyword">const</span> <span class="keyword">char</span> *divname, <a href="../ListOfTypes.html#Int_t">Int_t</a> iaxis, <a href="../ListOfTypes.html#Int_t">Int_t</a> ndiv,
                             <a href="../ListOfTypes.html#Double_t">Double_t</a> start, <a href="../ListOfTypes.html#Double_t">Double_t</a> step)
{
<span class="comment">//--- <a href="../TUCNGeoCtub.html#TUCNGeoCtub:Divide" title="TGeoVolume* TUCNGeoCtub::Divide(TGeoVolume* voldiv,const char* divname,Int_t iaxis,Int_t ndiv,Double_t start,Double_t step)">Divide</a> this tube shape belonging to volume <span class="string">"voldiv"</span> into ndiv volumes</span>
<span class="comment">// called divname, from start position with the given step. Returns pointer</span>
<span class="comment">// to created division cell volume in case of Z divisions. For radial division</span>
<span class="comment">// creates all volumes with different shapes and returns pointer to volume that</span>
<span class="comment">// was divided. In case a wrong division axis is supplied, returns pointer to</span>
<span class="comment">// volume that was divided.</span>
   TGeoShape *shape;           <span class="comment">//--- shape to be created</span>
   TGeoVolume *vol;            <span class="comment">//--- division volume to be created</span>
   TGeoVolumeMulti *vmulti;    <span class="comment">//--- generic divided volume</span>
   TGeoPatternFinder *finder;  <span class="comment">//--- finder to be attached</span>
   TString opt = <span class="string">""</span>;           <span class="comment">//--- option to be attached</span>
   <a href="../ListOfTypes.html#Int_t">Int_t</a> id;
   <a href="../ListOfTypes.html#Double_t">Double_t</a> end = start+ndiv*step;
   <span class="keyword">switch</span> (iaxis) {
      <span class="keyword">case</span> 1:  <span class="comment">//---                R division</span>
         finder = <span class="keyword">new</span> TGeoPatternCylR(voldiv, ndiv, start, end);
         vmulti = gGeoManager-&gt;MakeVolumeMulti(divname, voldiv-&gt;GetMedium());
         voldiv-&gt;SetFinder(finder);
         finder-&gt;SetDivIndex(voldiv-&gt;GetNdaughters());
         <span class="keyword">for</span> (id=0; id&lt;ndiv; id++) {
            shape = <span class="keyword">new</span> <a href="../TUCNGeoTube.html">TUCNGeoTube</a>(start+id*step, start+(id+1)*step, fDz);
            vol = <span class="keyword">new</span> TGeoVolume(divname, shape, voldiv-&gt;GetMedium());
            vmulti-&gt;AddVolume(vol);
            opt = <span class="string">"R"</span>;
            voldiv-&gt;AddNodeOffset(vol, id, 0, opt.Data());
            ((TGeoNodeOffset*)voldiv-&gt;GetNodes()-&gt;At(voldiv-&gt;GetNdaughters()-1))-&gt;SetFinder(finder);
         }
         <span class="keyword">return</span> vmulti;
      <span class="keyword">case</span> 2:  <span class="comment">//---                Phi division</span>
         finder = <span class="keyword">new</span> TGeoPatternCylPhi(voldiv, ndiv, start, end);
         voldiv-&gt;SetFinder(finder);
         finder-&gt;SetDivIndex(voldiv-&gt;GetNdaughters());
         shape = <span class="keyword">new</span> <a href="../TUCNGeoTubeSeg.html">TUCNGeoTubeSeg</a>(fRmin, fRmax, fDz, -step/2, step/2);
         vol = <span class="keyword">new</span> TGeoVolume(divname, shape, voldiv-&gt;GetMedium());
         vmulti = gGeoManager-&gt;MakeVolumeMulti(divname, voldiv-&gt;GetMedium());
         vmulti-&gt;AddVolume(vol);
         opt = <span class="string">"Phi"</span>;
         <span class="keyword">for</span> (id=0; id&lt;ndiv; id++) {
            voldiv-&gt;AddNodeOffset(vol, id, start+id*step+step/2, opt.Data());
            ((TGeoNodeOffset*)voldiv-&gt;GetNodes()-&gt;At(voldiv-&gt;GetNdaughters()-1))-&gt;SetFinder(finder);
         }
         <span class="keyword">return</span> vmulti;
      <span class="keyword">case</span> 3: <span class="comment">//---                  Z division</span>
         finder = <span class="keyword">new</span> TGeoPatternZ(voldiv, ndiv, start, start+ndiv*step);
         voldiv-&gt;SetFinder(finder);
         finder-&gt;SetDivIndex(voldiv-&gt;GetNdaughters());
         shape = <span class="keyword">new</span> <a href="../TUCNGeoTube.html">TUCNGeoTube</a>(fRmin, fRmax, step/2);
         vol = <span class="keyword">new</span> TGeoVolume(divname, shape, voldiv-&gt;GetMedium());
         vmulti = gGeoManager-&gt;MakeVolumeMulti(divname, voldiv-&gt;GetMedium());
         vmulti-&gt;AddVolume(vol);
         opt = <span class="string">"Z"</span>;
         <span class="keyword">for</span> (id=0; id&lt;ndiv; id++) {
            voldiv-&gt;AddNodeOffset(vol, id, start+step/2+id*step, opt.Data());
            ((TGeoNodeOffset*)voldiv-&gt;GetNodes()-&gt;At(voldiv-&gt;GetNdaughters()-1))-&gt;SetFinder(finder);
         }
         <span class="keyword">return</span> vmulti;
      <span class="keyword">default</span>:
         <a href="../#TObject:Error" title="void TObject::Error(const char* method,const char* msgfmt)">Error</a>(<span class="string">"Divide"</span>, <span class="string">"In shape %s wrong axis type for division"</span>, <a href="../#TGeoShape:GetName" title="const char* TGeoShape::GetName()">GetName</a>());
         <span class="keyword">return</span> 0;
   }
}

<span class="comment">//_____________________________________________________________________________</span>
<span class="keyword">const</span> <span class="keyword">char</span> *<a href="../TUCNGeoTube.html">TUCNGeoTube</a>::<a href="../TUCNGeoTube.html#TUCNGeoTube:GetAxisName" title="const char* TUCNGeoTube::GetAxisName(Int_t iaxis)">GetAxisName</a>(<a href="../ListOfTypes.html#Int_t">Int_t</a> iaxis) <span class="keyword">const</span>
{
<span class="comment">// Returns name of axis IAXIS.</span>
   <span class="keyword">switch</span> (iaxis) {
      <span class="keyword">case</span> 1:
         <span class="keyword">return</span> <span class="string">"R"</span>;
      <span class="keyword">case</span> 2:
         <span class="keyword">return</span> <span class="string">"PHI"</span>;
      <span class="keyword">case</span> 3:
         <span class="keyword">return</span> <span class="string">"Z"</span>;
      <span class="keyword">default</span>:
         <span class="keyword">return</span> <span class="string">"UNDEFINED"</span>;
   }
}

<span class="comment">//_____________________________________________________________________________</span>
<a href="../ListOfTypes.html#Double_t">Double_t</a> <a href="../TUCNGeoTube.html">TUCNGeoTube</a>::<a href="../TUCNGeoTube.html#TUCNGeoTube:GetAxisRange" title="Double_t TUCNGeoTube::GetAxisRange(Int_t iaxis,Double_t&amp; xlo,Double_t&amp; xhi)">GetAxisRange</a>(<a href="../ListOfTypes.html#Int_t">Int_t</a> iaxis, <a href="../ListOfTypes.html#Double_t">Double_t</a> &amp;xlo, <a href="../ListOfTypes.html#Double_t">Double_t</a> &amp;xhi) <span class="keyword">const</span>
{
<span class="comment">// Get range of shape for a given axis.</span>
   xlo = 0;
   xhi = 0;
   <a href="../ListOfTypes.html#Double_t">Double_t</a> dx = 0;
   <span class="keyword">switch</span> (iaxis) {
      <span class="keyword">case</span> 1:
         xlo = fRmin;
         xhi = fRmax;
         dx = xhi-xlo;
         <span class="keyword">return</span> dx;
      <span class="keyword">case</span> 2:
         xlo = 0;
         xhi = 360;
         dx = 360;
         <span class="keyword">return</span> dx;
      <span class="keyword">case</span> 3:
         xlo = -fDz;
         xhi = fDz;
         dx = xhi-xlo;
         <span class="keyword">return</span> dx;
   }
   <span class="keyword">return</span> dx;
}

<span class="comment">//_____________________________________________________________________________</span>
<span class="keyword">void</span> <a href="../TUCNGeoTube.html">TUCNGeoTube</a>::<a href="../TUCNGeoTube.html#TUCNGeoTube:GetBoundingCylinder" title="void TUCNGeoTube::GetBoundingCylinder(Double_t* param)">GetBoundingCylinder</a>(<a href="../ListOfTypes.html#Double_t">Double_t</a> *param) <span class="keyword">const</span>
{
<span class="comment">//--- Fill vector param[4] with the bounding cylinder parameters. The order</span>
<span class="comment">// is the following : Rmin, Rmax, Phi1, Phi2, dZ</span>
   param[0] = fRmin; <span class="comment">// Rmin</span>
   param[0] *= param[0];
   param[1] = fRmax; <span class="comment">// Rmax</span>
   param[1] *= param[1];
   param[2] = 0.;    <span class="comment">// Phi1</span>
   param[3] = 360.;  <span class="comment">// Phi1</span>
}

<span class="comment">//_____________________________________________________________________________</span>
TGeoShape *<a href="../TUCNGeoTube.html">TUCNGeoTube</a>::<a href="../TUCNGeoTube.html#TUCNGeoTube:GetMakeRuntimeShape" title="TGeoShape* TUCNGeoTube::GetMakeRuntimeShape(TGeoShape* mother,TGeoMatrix* mat)">GetMakeRuntimeShape</a>(TGeoShape *mother, TGeoMatrix * <span class="comment">/*mat*/</span>) <span class="keyword">const</span>
{
<span class="comment">// in case shape has some negative parameters, these has to be computed</span>
<span class="comment">// in order to fit the mother</span>
   <span class="keyword">if</span> (!<a href="../#TGeoShape:TestShapeBit" title="Bool_t TGeoShape::TestShapeBit(UInt_t f)">TestShapeBit</a>(kGeoRunTimeShape)) <span class="keyword">return</span> 0;
   <a href="../ListOfTypes.html#Double_t">Double_t</a> rmin, rmax, dz;
   <a href="../ListOfTypes.html#Double_t">Double_t</a> xmin,xmax;
   rmin = fRmin;
   rmax = fRmax;
   dz = fDz;
   <span class="keyword">if</span> (fDz&lt;0) {
      mother-&gt;<a href="../TUCNGeoCtub.html#TUCNGeoCtub:GetAxisRange" title="Double_t TUCNGeoCtub::GetAxisRange(Int_t iaxis,Double_t&amp; xlo,Double_t&amp; xhi)">GetAxisRange</a>(3,xmin,xmax);
      <span class="keyword">if</span> (xmax&lt;0) <span class="keyword">return</span> 0;
      dz=xmax;
   }
   mother-&gt;<a href="../TUCNGeoCtub.html#TUCNGeoCtub:GetAxisRange" title="Double_t TUCNGeoCtub::GetAxisRange(Int_t iaxis,Double_t&amp; xlo,Double_t&amp; xhi)">GetAxisRange</a>(1,xmin,xmax);
   <span class="keyword">if</span> (fRmin&lt;0) {
      <span class="keyword">if</span> (xmin&lt;0) <span class="keyword">return</span> 0;
      rmin = xmin;
   }
   <span class="keyword">if</span> (fRmax&lt;0) {
      <span class="keyword">if</span> (xmax&lt;=0) <span class="keyword">return</span> 0;
      rmax = xmax;
   }

   <span class="keyword">return</span> (<span class="keyword">new</span> <a href="../TUCNGeoTube.html">TUCNGeoTube</a>(<a href="../#TGeoShape:GetName" title="const char* TGeoShape::GetName()">GetName</a>(), rmin, rmax, dz));
}

<span class="comment">//_____________________________________________________________________________</span>
<span class="keyword">void</span> <a href="../TUCNGeoTube.html">TUCNGeoTube</a>::<a href="../TUCNGeoTube.html#TUCNGeoTube:InspectShape" title="void TUCNGeoTube::InspectShape()">InspectShape</a>() <span class="keyword">const</span>
{
<span class="comment">// print shape parameters</span>
   printf(<span class="string">"*** Shape %s: TUCNGeoTube ***\n"</span>, <a href="../#TGeoShape:GetName" title="const char* TGeoShape::GetName()">GetName</a>());
   printf(<span class="string">"    Rmin = %11.5f\n"</span>, fRmin);
   printf(<span class="string">"    Rmax = %11.5f\n"</span>, fRmax);
   printf(<span class="string">"    dz   = %11.5f\n"</span>, fDz);
   printf(<span class="string">" Bounding box:\n"</span>);
   <a href="../TUCNGeoBBox.html">TUCNGeoBBox</a>::<a href="../#TGeoBBox:InspectShape" title="void TGeoBBox::InspectShape()">InspectShape</a>();
}

<span class="comment">//_____________________________________________________________________________</span>
TBuffer3D *<a href="../TUCNGeoTube.html">TUCNGeoTube</a>::<a href="../TUCNGeoTube.html#TUCNGeoTube:MakeBuffer3D" title="TBuffer3D* TUCNGeoTube::MakeBuffer3D()">MakeBuffer3D</a>() <span class="keyword">const</span>
{
   <span class="comment">// Creates a TBuffer3D describing *this* shape.</span>
   <span class="comment">// Coordinates are in local reference frame.</span>

   <a href="../ListOfTypes.html#Int_t">Int_t</a> n = gGeoManager-&gt;GetNsegments();
   <a href="../ListOfTypes.html#Int_t">Int_t</a> nbPnts = 4*n;
   <a href="../ListOfTypes.html#Int_t">Int_t</a> nbSegs = 8*n;
   <a href="../ListOfTypes.html#Int_t">Int_t</a> nbPols = 4*n;
   <span class="keyword">if</span> (!<a href="../TUCNGeoTube.html#TUCNGeoTube:HasRmin" title="Bool_t TUCNGeoTube::HasRmin()">HasRmin</a>()) {
      nbPnts = 2*(n+1);
      nbSegs = 5*n;
      nbPols = 3*n;
   }   
   TBuffer3D* buff = <span class="keyword">new</span> TBuffer3D(TBuffer3DTypes::kGeneric,
                                   nbPnts, 3*nbPnts, nbSegs, 3*nbSegs, nbPols, 6*nbPols);
   <span class="keyword">if</span> (buff)
   {
      <a href="../TUCNGeoCtub.html#TUCNGeoCtub:SetPoints" title="void TUCNGeoCtub::SetPoints(Double_t* points) or overloads">SetPoints</a>(buff-&gt;fPnts);
      <a href="../TUCNGeoTubeSeg.html#TUCNGeoTubeSeg:SetSegsAndPols" title="void TUCNGeoTubeSeg::SetSegsAndPols(TBuffer3D&amp; buff)">SetSegsAndPols</a>(*buff);
   }

   <span class="keyword">return</span> buff;
}

<span class="comment">//_____________________________________________________________________________</span>
<span class="keyword">void</span> <a href="../TUCNGeoTube.html">TUCNGeoTube</a>::<a href="../TUCNGeoTube.html#TUCNGeoTube:SetSegsAndPols" title="void TUCNGeoTube::SetSegsAndPols(TBuffer3D&amp; buff)">SetSegsAndPols</a>(TBuffer3D &amp;buffer) <span class="keyword">const</span>
{
<span class="comment">// Fill TBuffer3D structure for segments and polygons.</span>
   <a href="../ListOfTypes.html#Int_t">Int_t</a> i, j,indx;
   <a href="../ListOfTypes.html#Int_t">Int_t</a> n = gGeoManager-&gt;GetNsegments();
   <a href="../ListOfTypes.html#Int_t">Int_t</a> c = (((buffer.fColor) %8) -1) * 4;
   <span class="keyword">if</span> (c &lt; 0) c = 0;

   <span class="keyword">if</span> (<a href="../TUCNGeoTube.html#TUCNGeoTube:HasRmin" title="Bool_t TUCNGeoTube::HasRmin()">HasRmin</a>()) {
      <span class="comment">// circle segments:</span>
      <span class="comment">// lower rmin circle: i=0, (0, n-1)</span>
      <span class="comment">// lower rmax circle: i=1, (n, 2n-1)</span>
      <span class="comment">// upper rmin circle: i=2, (2n, 3n-1)</span>
      <span class="comment">// upper rmax circle: i=1, (3n, 4n-1)</span>
      <span class="keyword">for</span> (i = 0; i &lt; 4; i++) {
         <span class="keyword">for</span> (j = 0; j &lt; n; j++) {
            indx = 3*(i*n+j);
            buffer.fSegs[indx  ] = c;
            buffer.fSegs[indx+1] = i*n+j;
            buffer.fSegs[indx+2] = i*n+(j+1)%n;
         }
      }
      <span class="comment">// Z-parallel segments</span>
      <span class="comment">// inner: i=4, (4n, 5n-1)</span>
      <span class="comment">// outer: i=5, (5n, 6n-1)</span>
      <span class="keyword">for</span> (i = 4; i &lt; 6; i++) {
         <span class="keyword">for</span> (j = 0; j &lt; n; j++) {
            indx = 3*(i*n+j);
            buffer.fSegs[indx  ] = c+1;
            buffer.fSegs[indx+1] = (i-4)*n+j;
            buffer.fSegs[indx+2] = (i-2)*n+j;
         }
      }
      <span class="comment">// Radial segments</span>
      <span class="comment">// lower: i=6, (6n, 7n-1)</span>
      <span class="comment">// upper: i=7, (7n, 8n-1)</span>
      <span class="keyword">for</span> (i = 6; i &lt; 8; i++) {
         <span class="keyword">for</span> (j = 0; j &lt; n; j++) {
            indx = 3*(i*n+j);
            buffer.fSegs[indx  ] = c;
            buffer.fSegs[indx+1] = 2*(i-6)*n+j;
            buffer.fSegs[indx+2] = (2*(i-6)+1)*n+j;
         }
      }
      <span class="comment">// Polygons</span>
      i=0;
      <span class="comment">// Inner lateral (0, n-1)</span>
      <span class="keyword">for</span> (j = 0; j &lt; n; j++) {
         indx = 6*(i*n+j);
         buffer.fPols[indx  ] = c;
         buffer.fPols[indx+1] = 4;
         buffer.fPols[indx+2] = j;
         buffer.fPols[indx+3] = 4*n+(j+1)%n;
         buffer.fPols[indx+4] = 2*n+j;
         buffer.fPols[indx+5] = 4*n+j;
      }
      i=1;
      <span class="comment">// Outer lateral (n,2n-1)</span>
      <span class="keyword">for</span> (j = 0; j &lt; n; j++) {
         indx = 6*(i*n+j);
         buffer.fPols[indx  ] = c+1;
         buffer.fPols[indx+1] = 4;
         buffer.fPols[indx+2] = n+j;
         buffer.fPols[indx+3] = 5*n+j;
         buffer.fPols[indx+4] = 3*n+j;
         buffer.fPols[indx+5] = 5*n+(j+1)%n;
      }
      i=2;
      <span class="comment">// lower disc (2n, 3n-1)</span>
      <span class="keyword">for</span> (j = 0; j &lt; n; j++) {
         indx = 6*(i*n+j);
         buffer.fPols[indx  ] = c;
         buffer.fPols[indx+1] = 4;
         buffer.fPols[indx+2] = j;
         buffer.fPols[indx+3] = 6*n+j;
         buffer.fPols[indx+4] = n+j;
         buffer.fPols[indx+5] = 6*n+(j+1)%n;
      }
      i=3;
      <span class="comment">// upper disc (3n, 4n-1)</span>
      <span class="keyword">for</span> (j = 0; j &lt; n; j++) {
         indx = 6*(i*n+j);
         buffer.fPols[indx  ] = c;
         buffer.fPols[indx+1] = 4;
         buffer.fPols[indx+2] = 2*n+j;
         buffer.fPols[indx+3] = 7*n+(j+1)%n;
         buffer.fPols[indx+4] = 3*n+j;
         buffer.fPols[indx+5] = 7*n+j;
      }
      <span class="keyword">return</span>;
   }
   <span class="comment">// Rmin=0 tubes</span>
   <span class="comment">// circle segments</span>
   <span class="comment">// lower rmax circle: i=0, (0, n-1)</span>
   <span class="comment">// upper rmax circle: i=1, (n, 2n-1)</span>
   <span class="keyword">for</span> (i = 0; i &lt; 2; i++) {
      <span class="keyword">for</span> (j = 0; j &lt; n; j++) {
         indx = 3*(i*n+j);
         buffer.fSegs[indx  ] = c;
         buffer.fSegs[indx+1] = 2+i*n+j;
         buffer.fSegs[indx+2] = 2+i*n+(j+1)%n;
      }
   }
   <span class="comment">// Z-parallel segments (2n,3n-1)</span>
   <span class="keyword">for</span> (j = 0; j &lt; n; j++) {
      indx = 3*(2*n+j);
      buffer.fSegs[indx  ] = c+1;
      buffer.fSegs[indx+1] = 2+j;
      buffer.fSegs[indx+2] = 2+n+j;
   }
   <span class="comment">// Radial segments</span>
   <span class="comment">// Lower circle: i=3, (3n,4n-1)</span>
   <span class="comment">// Upper circle: i=4, (4n,5n-1)</span>
   <span class="keyword">for</span> (i = 3; i &lt; 5; i++) {
      <span class="keyword">for</span> (j = 0; j &lt; n; j++) {
         indx = 3*(i*n+j);
         buffer.fSegs[indx  ] = c;
         buffer.fSegs[indx+1] = i-3;
         buffer.fSegs[indx+2] = 2+(i-3)*n+j;
      }
   }
   <span class="comment">// Polygons</span>
   <span class="comment">// lateral (0,n-1)</span>
   <span class="keyword">for</span> (j = 0; j &lt; n; j++) {
      indx = 6*j;
      buffer.fPols[indx  ] = c+1;
      buffer.fPols[indx+1] = 4;
      buffer.fPols[indx+2] = j;
      buffer.fPols[indx+3] = 2*n+j;
      buffer.fPols[indx+4] = n+j;
      buffer.fPols[indx+5] = 2*n+(j+1)%n;
   }
   <span class="comment">// bottom triangles (n,2n-1)</span>
   <span class="keyword">for</span> (j = 0; j &lt; n; j++) {
      indx = 6*n + 5*j;
      buffer.fPols[indx  ] = c;
      buffer.fPols[indx+1] = 3;
      buffer.fPols[indx+2] = j;
      buffer.fPols[indx+3] = 3*n+(j+1)%n;
      buffer.fPols[indx+4] = 3*n+j;
   }
   <span class="comment">// top triangles (2n,3n-1)  </span>
   <span class="keyword">for</span> (j = 0; j &lt; n; j++) {
      indx = 6*n + 5*n + 5*j;
      buffer.fPols[indx  ] = c;
      buffer.fPols[indx+1] = 3;
      buffer.fPols[indx+2] = n+j;
      buffer.fPols[indx+3] = 4*n+j;
      buffer.fPols[indx+4] = 4*n+(j+1)%n;
   }
}

<span class="comment">//_____________________________________________________________________________</span>
<a href="../ListOfTypes.html#Double_t">Double_t</a> <a href="../TUCNGeoTube.html">TUCNGeoTube</a>::<a href="../TUCNGeoTube.html#TUCNGeoTube:Safety" title="Double_t TUCNGeoTube::Safety(Double_t* point,Bool_t in=kTRUE)">Safety</a>(<a href="../ListOfTypes.html#Double_t">Double_t</a> *point, <a href="../ListOfTypes.html#Bool_t">Bool_t</a> in) <span class="keyword">const</span>
{
<span class="comment">// computes the closest distance from given point to this shape, according</span>
<span class="comment">// to option. The matching point on the shape is stored in spoint.</span>
<span class="cpp">#ifndef NEVER</span>
   <a href="../ListOfTypes.html#Double_t">Double_t</a> r = TMath::Sqrt(point[0]*point[0]+point[1]*point[1]);
   <a href="../ListOfTypes.html#Double_t">Double_t</a> safe, safrmin, safrmax;
   <span class="keyword">if</span> (in) {
      safe    = fDz-TMath::Abs(point[2]); <span class="comment">// positive if inside</span>
      <span class="keyword">if</span> (fRmin&gt;1E-10) {
         safrmin = r-fRmin;
         <span class="keyword">if</span> (safrmin &lt; safe) safe = safrmin;
      }
      safrmax = fRmax-r;
      <span class="keyword">if</span> (safrmax &lt; safe) safe = safrmax;
   } <span class="keyword">else</span> {
      safe    = -fDz+TMath::Abs(point[2]);
      <span class="keyword">if</span> (fRmin&gt;1E-10) {
         safrmin = -r+fRmin;
         <span class="keyword">if</span> (safrmin &gt; safe) safe = safrmin;
      }
      safrmax = -fRmax+r;
      <span class="keyword">if</span> (safrmax &gt; safe) safe = safrmax;
   }
   <span class="keyword">return</span> safe;
<span class="cpp">#else</span>
   <a href="../ListOfTypes.html#Double_t">Double_t</a> saf[3];
   <a href="../ListOfTypes.html#Double_t">Double_t</a> rsq = point[0]*point[0]+point[1]*point[1];
   <a href="../ListOfTypes.html#Double_t">Double_t</a> r = TMath::Sqrt(rsq);
   saf[0] = fDz-TMath::Abs(point[2]); <span class="comment">// positive if inside</span>
   saf[1] = (fRmin&gt;1E-10)?(r-fRmin):TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
   saf[2] = fRmax-r;
   <span class="keyword">if</span> (in) <span class="keyword">return</span> saf[TMath::LocMin(3,saf)];
   <span class="keyword">for</span> (<a href="../ListOfTypes.html#Int_t">Int_t</a> i=0; i&lt;3; i++) saf[i]=-saf[i];
   <span class="keyword">return</span> saf[TMath::LocMax(3,saf)];
<span class="cpp">#endif</span>
}

<span class="comment">//_____________________________________________________________________________</span>
<a href="../ListOfTypes.html#Double_t">Double_t</a> <a href="../TUCNGeoTube.html">TUCNGeoTube</a>::<a href="../TUCNGeoTube.html#TUCNGeoTube:SafetyS" title="Double_t TUCNGeoTube::SafetyS(Double_t* point,Bool_t in,Double_t rmin,Double_t rmax,Double_t dz,Int_t skipz=0)">SafetyS</a>(<a href="../ListOfTypes.html#Double_t">Double_t</a> *point, <a href="../ListOfTypes.html#Bool_t">Bool_t</a> in, <a href="../ListOfTypes.html#Double_t">Double_t</a> rmin, <a href="../ListOfTypes.html#Double_t">Double_t</a> rmax, <a href="../ListOfTypes.html#Double_t">Double_t</a> dz, <a href="../ListOfTypes.html#Int_t">Int_t</a> skipz)
{
<span class="comment">// computes the closest distance from given point to this shape, according</span>
<span class="comment">// to option. The matching point on the shape is stored in spoint.</span>
   <a href="../ListOfTypes.html#Double_t">Double_t</a> saf[3];
   <a href="../ListOfTypes.html#Double_t">Double_t</a> rsq = point[0]*point[0]+point[1]*point[1];
   <a href="../ListOfTypes.html#Double_t">Double_t</a> r = TMath::Sqrt(rsq);
   <span class="keyword">switch</span> (skipz) {
      <span class="keyword">case</span> 1: <span class="comment">// skip lower Z plane</span>
         saf[0] = dz - point[2];
         <span class="keyword">break</span>;
      <span class="keyword">case</span> 2: <span class="comment">// skip upper Z plane</span>
         saf[0] = dz + point[2];
         <span class="keyword">break</span>;
      <span class="keyword">case</span> 3: <span class="comment">// skip both</span>
         saf[0] = TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
         <span class="keyword">break</span>;
      <span class="keyword">default</span>:
         saf[0] = dz-TMath::Abs(point[2]);
   }
   saf[1] = (rmin&gt;1E-10)?(r-rmin):TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
   saf[2] = rmax-r;
<span class="comment">//   printf(<span class="string">"saf0=%g saf1=%g saf2=%g in=%d skipz=%d\n"</span>, saf[0],saf[1],saf[2],in,skipz);</span>
   <span class="keyword">if</span> (in) <span class="keyword">return</span> saf[TMath::LocMin(3,saf)];
   <span class="keyword">for</span> (<a href="../ListOfTypes.html#Int_t">Int_t</a> i=0; i&lt;3; i++) saf[i]=-saf[i];
   <span class="keyword">return</span> saf[TMath::LocMax(3,saf)];
}

<span class="comment">//_____________________________________________________________________________</span>
<span class="keyword">void</span> <a href="../TUCNGeoTube.html">TUCNGeoTube</a>::<a href="../TUCNGeoTube.html#TUCNGeoTube:SavePrimitive" title="void TUCNGeoTube::SavePrimitive(ostream&amp; out,Option_t* option=&quot;&quot;)">SavePrimitive</a>(<a href="../ListOfTypes.html#ostream">ostream</a> &amp;out, <a href="../ListOfTypes.html#Option_t">Option_t</a> * <span class="comment">/*option*/</span> <span class="comment">/*= <span class="string">""</span>*/</span>)
{
<span class="comment">// Save a primitive as a C++ statement(s) on output stream <span class="string">"out"</span>.</span>
   <span class="keyword">if</span> (<a href="../#TObject:TObject" title="TObject TObject::TObject() or overloads">TObject</a>::<a href="../#TObject:TestBit" title="Bool_t TObject::TestBit(UInt_t f)">TestBit</a>(kGeoSavePrimitive)) <span class="keyword">return</span>;
   out &lt;&lt; <span class="string">"   // Shape: "</span> &lt;&lt; <a href="../#TGeoShape:GetName" title="const char* TGeoShape::GetName()">GetName</a>() &lt;&lt; <span class="string">" type: "</span> &lt;&lt; <a href="../#TObject:ClassName" title="const char* TObject::ClassName()">ClassName</a>() &lt;&lt; endl;
   out &lt;&lt; <span class="string">"   rmin = "</span> &lt;&lt; fRmin &lt;&lt; <span class="string">";"</span> &lt;&lt; endl;
   out &lt;&lt; <span class="string">"   rmax = "</span> &lt;&lt; fRmax &lt;&lt; <span class="string">";"</span> &lt;&lt; endl;
   out &lt;&lt; <span class="string">"   dz   = "</span> &lt;&lt; fDz &lt;&lt; <span class="string">";"</span> &lt;&lt; endl;
   out &lt;&lt; <span class="string">"   TGeoShape *"</span> &lt;&lt; <a href="../#TGeoShape:GetPointerName" title="char* TGeoShape::GetPointerName()">GetPointerName</a>() &lt;&lt; <span class="string">" = new TUCNGeoTube(\""</span> &lt;&lt; <a href="../#TGeoShape:GetName" title="const char* TGeoShape::GetName()">GetName</a>() &lt;&lt; <span class="string">"\",rmin,rmax,dz);"</span> &lt;&lt; endl;
   <a href="../#TObject:TObject" title="TObject TObject::TObject() or overloads">TObject</a>::<a href="../#TObject:SetBit" title="void TObject::SetBit(UInt_t f,Bool_t set) or overloads">SetBit</a>(TGeoShape::kGeoSavePrimitive);
}

<span class="comment">//_____________________________________________________________________________</span>
<span class="keyword">void</span> <a href="../TUCNGeoTube.html">TUCNGeoTube</a>::<a href="../TUCNGeoTube.html#TUCNGeoTube:SetTubeDimensions" title="void TUCNGeoTube::SetTubeDimensions(Double_t rmin,Double_t rmax,Double_t dz)">SetTubeDimensions</a>(<a href="../ListOfTypes.html#Double_t">Double_t</a> rmin, <a href="../ListOfTypes.html#Double_t">Double_t</a> rmax, <a href="../ListOfTypes.html#Double_t">Double_t</a> dz)
{
<span class="comment">// Set tube dimensions.</span>
   fRmin = rmin;
   fRmax = rmax;
   fDz   = dz;
   <span class="keyword">if</span> (fRmin&gt;0 &amp;&amp; fRmax&gt;0 &amp;&amp; fRmin&gt;=fRmax)
      <a href="../#TObject:Error" title="void TObject::Error(const char* method,const char* msgfmt)">Error</a>(<span class="string">"SetTubeDimensions"</span>, <span class="string">"In shape %s wrong rmin=%g rmax=%g"</span>, <a href="../#TGeoShape:GetName" title="const char* TGeoShape::GetName()">GetName</a>(), rmin,rmax);
}

<span class="comment">//_____________________________________________________________________________</span>
<span class="keyword">void</span> <a href="../TUCNGeoTube.html">TUCNGeoTube</a>::<a href="../TUCNGeoTube.html#TUCNGeoTube:SetDimensions" title="void TUCNGeoTube::SetDimensions(Double_t* param)">SetDimensions</a>(<a href="../ListOfTypes.html#Double_t">Double_t</a> *param)
{
<span class="comment">// Set tube dimensions starting from a list.</span>
   <a href="../ListOfTypes.html#Double_t">Double_t</a> rmin = param[0];
   <a href="../ListOfTypes.html#Double_t">Double_t</a> rmax = param[1];
   <a href="../ListOfTypes.html#Double_t">Double_t</a> dz   = param[2];
   <a href="../TUCNGeoTube.html#TUCNGeoTube:SetTubeDimensions" title="void TUCNGeoTube::SetTubeDimensions(Double_t rmin,Double_t rmax,Double_t dz)">SetTubeDimensions</a>(rmin, rmax, dz);
}

<span class="comment">//_____________________________________________________________________________</span>
<a href="../ListOfTypes.html#Bool_t">Bool_t</a> <a href="../TUCNGeoTube.html">TUCNGeoTube</a>::<a href="../TUCNGeoTube.html#TUCNGeoTube:GetPointsOnSegments" title="Bool_t TUCNGeoTube::GetPointsOnSegments(Int_t npoints,Double_t* array)">GetPointsOnSegments</a>(<a href="../ListOfTypes.html#Int_t">Int_t</a> npoints, <a href="../ListOfTypes.html#Double_t">Double_t</a> *array) <span class="keyword">const</span>
{
<span class="comment">// Fills array with n random points located on the line segments of the shape mesh.</span>
<span class="comment">// The output array must be provided with a length of minimum 3*npoints. Returns</span>
<span class="comment">// <a href="../ListOfTypes.html#bool">true</a> if operation is implemented.</span>
   <span class="keyword">if</span> (npoints &gt; (npoints/2)*2) {
      <a href="../#TObject:Error" title="void TObject::Error(const char* method,const char* msgfmt)">Error</a>(<span class="string">"GetPointsOnSegments"</span>,<span class="string">"Npoints must be even number"</span>);
      <span class="keyword">return</span> <a href="../ListOfTypes.html#Bool_t">kFALSE</a>;
   }   
   <a href="../ListOfTypes.html#Int_t">Int_t</a> nc = 0;
   <span class="keyword">if</span> (<a href="../TUCNGeoTube.html#TUCNGeoTube:HasRmin" title="Bool_t TUCNGeoTube::HasRmin()">HasRmin</a>()) nc = (<a href="../ListOfTypes.html#Int_t">Int_t</a>)TMath::Sqrt(0.5*npoints);
   <span class="keyword">else</span>           nc = (<a href="../ListOfTypes.html#Int_t">Int_t</a>)TMath::Sqrt(1.*npoints);
   <a href="../ListOfTypes.html#Double_t">Double_t</a> dphi = TMath::TwoPi()/nc;
   <a href="../ListOfTypes.html#Double_t">Double_t</a> phi = 0;
   <a href="../ListOfTypes.html#Int_t">Int_t</a> ntop = 0;
   <span class="keyword">if</span> (<a href="../TUCNGeoTube.html#TUCNGeoTube:HasRmin" title="Bool_t TUCNGeoTube::HasRmin()">HasRmin</a>()) ntop = npoints/2 - nc*(nc-1);
   <span class="keyword">else</span>           ntop = npoints - nc*(nc-1);
   <a href="../ListOfTypes.html#Double_t">Double_t</a> dz = 2*fDz/(nc-1);
   <a href="../ListOfTypes.html#Double_t">Double_t</a> z = 0;
   <a href="../ListOfTypes.html#Int_t">Int_t</a> icrt = 0;
   <a href="../ListOfTypes.html#Int_t">Int_t</a> nphi = nc;
   <span class="comment">// loop z sections</span>
   <span class="keyword">for</span> (<a href="../ListOfTypes.html#Int_t">Int_t</a> i=0; i&lt;nc; i++) {
      <span class="keyword">if</span> (i == (nc-1)) nphi = ntop;
      z = -fDz + i*dz;
      <span class="comment">// loop points on circle sections</span>
      <span class="keyword">for</span> (<a href="../ListOfTypes.html#Int_t">Int_t</a> j=0; j&lt;nphi; j++) {
         phi = j*dphi;
         <span class="keyword">if</span> (<a href="../TUCNGeoTube.html#TUCNGeoTube:HasRmin" title="Bool_t TUCNGeoTube::HasRmin()">HasRmin</a>()) {
            array[icrt++] = fRmin * TMath::Cos(phi);
            array[icrt++] = fRmin * TMath::Sin(phi);
            array[icrt++] = z;
         }
         array[icrt++] = fRmax * TMath::Cos(phi);
         array[icrt++] = fRmax * TMath::Sin(phi);
         array[icrt++] = z;
      }
   }
   <span class="keyword">return</span> <a href="../ListOfTypes.html#Bool_t">kTRUE</a>;
}                    

<span class="comment">//_____________________________________________________________________________</span>
<span class="keyword">void</span> <a href="../TUCNGeoTube.html">TUCNGeoTube</a>::<a href="../TUCNGeoTube.html#TUCNGeoTube:SetPoints" title="void TUCNGeoTube::SetPoints(Double_t* points) or overloads">SetPoints</a>(<a href="../ListOfTypes.html#Double_t">Double_t</a> *points) <span class="keyword">const</span>
{
<span class="comment">// create tube mesh points</span>
   <a href="../ListOfTypes.html#Double_t">Double_t</a> dz;
   <a href="../ListOfTypes.html#Int_t">Int_t</a> j, n;
   n = gGeoManager-&gt;GetNsegments();
   <a href="../ListOfTypes.html#Double_t">Double_t</a> dphi = 360./n;
   <a href="../ListOfTypes.html#Double_t">Double_t</a> phi = 0;
   dz = fDz;
   <a href="../ListOfTypes.html#Int_t">Int_t</a> indx = 0;
   <span class="keyword">if</span> (points) {
      <span class="keyword">if</span> (<a href="../TUCNGeoTube.html#TUCNGeoTube:HasRmin" title="Bool_t TUCNGeoTube::HasRmin()">HasRmin</a>()) {
         <span class="comment">// 4*n points</span>
         <span class="comment">// (0,n-1) lower rmin circle</span>
         <span class="comment">// (2n, 3n-1) upper rmin circle</span>
         <span class="keyword">for</span> (j = 0; j &lt; n; j++) {
            phi = j*dphi*TMath::DegToRad();
            points[indx+6*n] = points[indx] = fRmin * TMath::Cos(phi);
            indx++;
            points[indx+6*n] = points[indx] = fRmin * TMath::Sin(phi);
            indx++;
            points[indx+6*n] = dz;
            points[indx]     =-dz;
            indx++;
         }   
         <span class="comment">// (n, 2n-1) lower rmax circle</span>
         <span class="comment">// (3n, 4n-1) upper rmax circle</span>
         <span class="keyword">for</span> (j = 0; j &lt; n; j++) {
            phi = j*dphi*TMath::DegToRad();
            points[indx+6*n] = points[indx] = fRmax * TMath::Cos(phi);
            indx++;
            points[indx+6*n] = points[indx] = fRmax * TMath::Sin(phi);
            indx++;
            points[indx+6*n]= dz;
            points[indx]    =-dz;
            indx++;
         }
      } <span class="keyword">else</span> {
         <span class="comment">// centers of lower/upper circles (0,1)</span>
         points[indx++] = 0.;
         points[indx++] = 0.;
         points[indx++] = -dz;
         points[indx++] = 0.;
         points[indx++] = 0.;
         points[indx++] = dz;
         <span class="comment">// lower rmax circle (2, 2+n-1)</span>
         <span class="comment">// upper rmax circle (2+n, 2+2n-1)</span>
         <span class="keyword">for</span> (j = 0; j &lt; n; j++) {
            phi = j*dphi*TMath::DegToRad();
            points[indx+3*n] = points[indx] = fRmax * TMath::Cos(phi);
            indx++;
            points[indx+3*n] = points[indx] = fRmax * TMath::Sin(phi);
            indx++;
            points[indx+3*n]= dz;
            points[indx]    =-dz;
            indx++;
         }
      }   
   }
}

<span class="comment">//_____________________________________________________________________________</span>
<span class="keyword">void</span> <a href="../TUCNGeoTube.html">TUCNGeoTube</a>::<a href="../TUCNGeoTube.html#TUCNGeoTube:SetPoints" title="void TUCNGeoTube::SetPoints(Double_t* points) or overloads">SetPoints</a>(<a href="../ListOfTypes.html#Float_t">Float_t</a> *points) <span class="keyword">const</span>
{
<span class="comment">// create tube mesh points</span>
   <a href="../ListOfTypes.html#Double_t">Double_t</a> dz;
   <a href="../ListOfTypes.html#Int_t">Int_t</a> j, n;
   n = gGeoManager-&gt;GetNsegments();
   <a href="../ListOfTypes.html#Double_t">Double_t</a> dphi = 360./n;
   <a href="../ListOfTypes.html#Double_t">Double_t</a> phi = 0;
   dz = fDz;
   <a href="../ListOfTypes.html#Int_t">Int_t</a> indx = 0;
   <span class="keyword">if</span> (points) {
      <span class="keyword">if</span> (<a href="../TUCNGeoTube.html#TUCNGeoTube:HasRmin" title="Bool_t TUCNGeoTube::HasRmin()">HasRmin</a>()) {
         <span class="comment">// 4*n points</span>
         <span class="comment">// (0,n-1) lower rmin circle</span>
         <span class="comment">// (2n, 3n-1) upper rmin circle</span>
         <span class="keyword">for</span> (j = 0; j &lt; n; j++) {
            phi = j*dphi*TMath::DegToRad();
            points[indx+6*n] = points[indx] = fRmin * TMath::Cos(phi);
            indx++;
            points[indx+6*n] = points[indx] = fRmin * TMath::Sin(phi);
            indx++;
            points[indx+6*n] = dz;
            points[indx]     =-dz;
            indx++;
         }   
         <span class="comment">// (n, 2n-1) lower rmax circle</span>
         <span class="comment">// (3n, 4n-1) upper rmax circle</span>
         <span class="keyword">for</span> (j = 0; j &lt; n; j++) {
            phi = j*dphi*TMath::DegToRad();
            points[indx+6*n] = points[indx] = fRmax * TMath::Cos(phi);
            indx++;
            points[indx+6*n] = points[indx] = fRmax * TMath::Sin(phi);
            indx++;
            points[indx+6*n]= dz;
            points[indx]    =-dz;
            indx++;
         }
      } <span class="keyword">else</span> {
         <span class="comment">// centers of lower/upper circles (0,1)</span>
         points[indx++] = 0.;
         points[indx++] = 0.;
         points[indx++] = -dz;
         points[indx++] = 0.;
         points[indx++] = 0.;
         points[indx++] = dz;
         <span class="comment">// lower rmax circle (2, 2+n-1)</span>
         <span class="comment">// upper rmax circle (2+n, 2+2n-1)</span>
         <span class="keyword">for</span> (j = 0; j &lt; n; j++) {
            phi = j*dphi*TMath::DegToRad();
            points[indx+3*n] = points[indx] = fRmax * TMath::Cos(phi);
            indx++;
            points[indx+3*n] = points[indx] = fRmax * TMath::Sin(phi);
            indx++;
            points[indx+3*n]= dz;
            points[indx]    =-dz;
            indx++;
         }
      }   
   }
}

<span class="comment">//_____________________________________________________________________________</span>
<a href="../ListOfTypes.html#Int_t">Int_t</a> <a href="../TUCNGeoTube.html">TUCNGeoTube</a>::<a href="../TUCNGeoTube.html#TUCNGeoTube:GetNmeshVertices" title="Int_t TUCNGeoTube::GetNmeshVertices()">GetNmeshVertices</a>() <span class="keyword">const</span>
{
<span class="comment">// Return number of vertices of the mesh representation</span>
   <a href="../ListOfTypes.html#Int_t">Int_t</a> n = gGeoManager-&gt;GetNsegments();
   <a href="../ListOfTypes.html#Int_t">Int_t</a> numPoints = n*4;
   <span class="keyword">if</span> (!<a href="../TUCNGeoTube.html#TUCNGeoTube:HasRmin" title="Bool_t TUCNGeoTube::HasRmin()">HasRmin</a>()) numPoints = 2*(n+1);
   <span class="keyword">return</span> numPoints;
}

<span class="comment">//_____________________________________________________________________________</span>
<span class="keyword">void</span> <a href="../TUCNGeoTube.html">TUCNGeoTube</a>::<a href="../TUCNGeoTube.html#TUCNGeoTube:GetMeshNumbers" title="void TUCNGeoTube::GetMeshNumbers(Int_t&amp; nvert,Int_t&amp; nsegs,Int_t&amp; npols)">GetMeshNumbers</a>(<a href="../ListOfTypes.html#Int_t">Int_t</a> &amp;nvert, <a href="../ListOfTypes.html#Int_t">Int_t</a> &amp;nsegs, <a href="../ListOfTypes.html#Int_t">Int_t</a> &amp;npols) <span class="keyword">const</span>
{
<span class="comment">// Returns numbers of vertices, segments and polygons composing the shape mesh.</span>
   <a href="../ListOfTypes.html#Int_t">Int_t</a> n = gGeoManager-&gt;GetNsegments();
   nvert = n*4;
   nsegs = n*8;
   npols = n*4;
   <span class="keyword">if</span> (!<a href="../TUCNGeoTube.html#TUCNGeoTube:HasRmin" title="Bool_t TUCNGeoTube::HasRmin()">HasRmin</a>()) {
      nvert = 2*(n+1);
      nsegs = 5*n;
      npols = 3*n;
   } <span class="keyword">else</span> {
      nvert = n*4;
      nsegs = n*8;
      npols = n*4;
   }   
}

<span class="comment">//_____________________________________________________________________________</span>
<span class="keyword">void</span> <a href="../TUCNGeoTube.html">TUCNGeoTube</a>::<a href="../TUCNGeoTube.html#TUCNGeoTube:Sizeof3D" title="void TUCNGeoTube::Sizeof3D()">Sizeof3D</a>() <span class="keyword">const</span>
{
<span class="comment">///// fill size of this 3-D object</span>
<span class="comment">///    TVirtualGeoPainter *painter = gGeoManager-&gt;GetGeomPainter();</span>
<span class="comment">///    if (!painter) return;</span>
<span class="comment">///    <a href="../ListOfTypes.html#Int_t">Int_t</a> n = gGeoManager-&gt;GetNsegments();</span>
<span class="comment">///    <a href="../ListOfTypes.html#Int_t">Int_t</a> numPoints = n*4;</span>
<span class="comment">///    <a href="../ListOfTypes.html#Int_t">Int_t</a> numSegs   = n*8;</span>
<span class="comment">///    <a href="../ListOfTypes.html#Int_t">Int_t</a> numPolys  = n*4;</span>
<span class="comment">///    painter-&gt;AddSize3D(numPoints, numSegs, numPolys);</span>
}

<span class="comment">//_____________________________________________________________________________</span>
<span class="keyword">const</span> TBuffer3D &amp; <a href="../TUCNGeoTube.html">TUCNGeoTube</a>::<a href="../TUCNGeoTube.html#TUCNGeoTube:GetBuffer3D" title="const TBuffer3D&amp; TUCNGeoTube::GetBuffer3D(Int_t reqSections,Bool_t localFrame)">GetBuffer3D</a>(<a href="../ListOfTypes.html#Int_t">Int_t</a> reqSections, <a href="../ListOfTypes.html#Bool_t">Bool_t</a> localFrame) <span class="keyword">const</span>
{
<span class="comment">// Fills a static 3D buffer and returns a reference.</span>
   <span class="keyword">static</span> TBuffer3DTube buffer;
   <a href="../TUCNGeoBBox.html">TUCNGeoBBox</a>::<a href="../#TGeoBBox:FillBuffer3D" title="void TGeoBBox::FillBuffer3D(TBuffer3D&amp; buffer,Int_t reqSections,Bool_t localFrame)">FillBuffer3D</a>(buffer, reqSections, localFrame);

   <span class="keyword">if</span> (reqSections &amp; TBuffer3D::kShapeSpecific) {
      buffer.fRadiusInner  = fRmin;
      buffer.fRadiusOuter  = fRmax;
      buffer.fHalfLength   = fDz;
      buffer.SetSectionsValid(TBuffer3D::kShapeSpecific);
   }
   <span class="keyword">if</span> (reqSections &amp; TBuffer3D::kRawSizes) {
      <a href="../ListOfTypes.html#Int_t">Int_t</a> n = gGeoManager-&gt;GetNsegments();
      <a href="../ListOfTypes.html#Int_t">Int_t</a> nbPnts = 4*n;
      <a href="../ListOfTypes.html#Int_t">Int_t</a> nbSegs = 8*n;
      <a href="../ListOfTypes.html#Int_t">Int_t</a> nbPols = 4*n;
      <span class="keyword">if</span> (!<a href="../TUCNGeoTube.html#TUCNGeoTube:HasRmin" title="Bool_t TUCNGeoTube::HasRmin()">HasRmin</a>()) {
         nbPnts = 2*(n+1);
         nbSegs = 5*n;
         nbPols = 3*n;
      }   
      <span class="keyword">if</span> (buffer.SetRawSizes(nbPnts, 3*nbPnts, nbSegs, 3*nbSegs, nbPols, 6*nbPols)) {
         buffer.SetSectionsValid(TBuffer3D::kRawSizes);
      }
   }
   <span class="keyword">if</span> ((reqSections &amp; TBuffer3D::kRaw) &amp;&amp; buffer.SectionsValid(TBuffer3D::kRawSizes)) {
      <a href="../TUCNGeoCtub.html#TUCNGeoCtub:SetPoints" title="void TUCNGeoCtub::SetPoints(Double_t* points) or overloads">SetPoints</a>(buffer.fPnts);
      <span class="keyword">if</span> (!buffer.fLocalFrame) {
         <a href="../#TGeoShape:TransformPoints" title="void TGeoShape::TransformPoints(Double_t* points,UInt_t NbPoints)">TransformPoints</a>(buffer.fPnts, buffer.NbPnts());
      }
      <a href="../TUCNGeoTubeSeg.html#TUCNGeoTubeSeg:SetSegsAndPols" title="void TUCNGeoTubeSeg::SetSegsAndPols(TBuffer3D&amp; buff)">SetSegsAndPols</a>(buffer);
      buffer.SetSectionsValid(TBuffer3D::kRaw);
   }

   <span class="keyword">return</span> buffer;
}

ClassImp(<a href="../TUCNGeoTubeSeg.html">TUCNGeoTubeSeg</a>)

<span class="comment">//_____________________________________________________________________________</span>
<a href="../TUCNGeoTubeSeg.html">TUCNGeoTubeSeg</a>::<a href="../TUCNGeoTubeSeg.html#TUCNGeoTubeSeg:TUCNGeoTubeSeg" title="TUCNGeoTubeSeg TUCNGeoTubeSeg::TUCNGeoTubeSeg() or overloads">TUCNGeoTubeSeg</a>()
{
<span class="comment">// Default constructor</span>
   <a href="../#TGeoShape:SetShapeBit" title="void TGeoShape::SetShapeBit(UInt_t f,Bool_t set) or overloads">SetShapeBit</a>(TGeoShape::kGeoTubeSeg);
   fPhi1 = fPhi2 = 0.0;
}

<span class="comment">//_____________________________________________________________________________</span>
<a href="../TUCNGeoTubeSeg.html">TUCNGeoTubeSeg</a>::<a href="../TUCNGeoTubeSeg.html#TUCNGeoTubeSeg:TUCNGeoTubeSeg" title="TUCNGeoTubeSeg TUCNGeoTubeSeg::TUCNGeoTubeSeg() or overloads">TUCNGeoTubeSeg</a>(<a href="../ListOfTypes.html#Double_t">Double_t</a> rmin, <a href="../ListOfTypes.html#Double_t">Double_t</a> rmax, <a href="../ListOfTypes.html#Double_t">Double_t</a> dz,
                          <a href="../ListOfTypes.html#Double_t">Double_t</a> phi1, <a href="../ListOfTypes.html#Double_t">Double_t</a> phi2)
            :<a href="../TUCNGeoTube.html">TUCNGeoTube</a>(rmin, rmax, dz)
{
<span class="comment">// Default constructor specifying minimum and maximum radius</span>
   <a href="../#TGeoShape:SetShapeBit" title="void TGeoShape::SetShapeBit(UInt_t f,Bool_t set) or overloads">SetShapeBit</a>(TGeoShape::kGeoTubeSeg);
   <a href="../TUCNGeoTubeSeg.html#TUCNGeoTubeSeg:SetTubsDimensions" title="void TUCNGeoTubeSeg::SetTubsDimensions(Double_t rmin,Double_t rmax,Double_t dz,Double_t phi1,Double_t phi2)">SetTubsDimensions</a>(rmin, rmax, dz, phi1, phi2);
   <a href="../TUCNGeoCtub.html#TUCNGeoCtub:ComputeBBox" title="void TUCNGeoCtub::ComputeBBox()">ComputeBBox</a>();
}

<span class="comment">//_____________________________________________________________________________</span>
<a href="../TUCNGeoTubeSeg.html">TUCNGeoTubeSeg</a>::<a href="../TUCNGeoTubeSeg.html#TUCNGeoTubeSeg:TUCNGeoTubeSeg" title="TUCNGeoTubeSeg TUCNGeoTubeSeg::TUCNGeoTubeSeg() or overloads">TUCNGeoTubeSeg</a>(<span class="keyword">const</span> <span class="keyword">char</span> *name, <a href="../ListOfTypes.html#Double_t">Double_t</a> rmin, <a href="../ListOfTypes.html#Double_t">Double_t</a> rmax, <a href="../ListOfTypes.html#Double_t">Double_t</a> dz,
                          <a href="../ListOfTypes.html#Double_t">Double_t</a> phi1, <a href="../ListOfTypes.html#Double_t">Double_t</a> phi2)
            :<a href="../TUCNGeoTube.html">TUCNGeoTube</a>(name, rmin, rmax, dz)
{
<span class="comment">// Default constructor specifying minimum and maximum radius</span>
   <a href="../#TGeoShape:SetShapeBit" title="void TGeoShape::SetShapeBit(UInt_t f,Bool_t set) or overloads">SetShapeBit</a>(TGeoShape::kGeoTubeSeg);
   <a href="../TUCNGeoTubeSeg.html#TUCNGeoTubeSeg:SetTubsDimensions" title="void TUCNGeoTubeSeg::SetTubsDimensions(Double_t rmin,Double_t rmax,Double_t dz,Double_t phi1,Double_t phi2)">SetTubsDimensions</a>(rmin, rmax, dz, phi1, phi2);
   <a href="../TUCNGeoCtub.html#TUCNGeoCtub:ComputeBBox" title="void TUCNGeoCtub::ComputeBBox()">ComputeBBox</a>();
}

<span class="comment">//_____________________________________________________________________________</span>
<a href="../TUCNGeoTubeSeg.html">TUCNGeoTubeSeg</a>::<a href="../TUCNGeoTubeSeg.html#TUCNGeoTubeSeg:TUCNGeoTubeSeg" title="TUCNGeoTubeSeg TUCNGeoTubeSeg::TUCNGeoTubeSeg() or overloads">TUCNGeoTubeSeg</a>(<a href="../ListOfTypes.html#Double_t">Double_t</a> *param)
            :<a href="../TUCNGeoTube.html">TUCNGeoTube</a>(0, 0, 0)
{
<span class="comment">// Default constructor specifying minimum and maximum radius</span>
<span class="comment">// param[0] = Rmin</span>
<span class="comment">// param[1] = Rmax</span>
<span class="comment">// param[2] = dz</span>
<span class="comment">// param[3] = phi1</span>
<span class="comment">// param[4] = phi2</span>
   <a href="../#TGeoShape:SetShapeBit" title="void TGeoShape::SetShapeBit(UInt_t f,Bool_t set) or overloads">SetShapeBit</a>(TGeoShape::kGeoTubeSeg);
   <a href="../TUCNGeoCtub.html#TUCNGeoCtub:SetDimensions" title="void TUCNGeoCtub::SetDimensions(Double_t* param)">SetDimensions</a>(param);
   <a href="../TUCNGeoCtub.html#TUCNGeoCtub:ComputeBBox" title="void TUCNGeoCtub::ComputeBBox()">ComputeBBox</a>();
}

<span class="comment">//_____________________________________________________________________________</span>
<a href="../TUCNGeoTubeSeg.html">TUCNGeoTubeSeg</a>::<a href="../TUCNGeoTubeSeg.html#TUCNGeoTubeSeg:_TUCNGeoTubeSeg" title="void TUCNGeoTubeSeg::~TUCNGeoTubeSeg()">~TUCNGeoTubeSeg</a>()
{
<span class="comment">// destructor</span>
}

<span class="comment">//_____________________________________________________________________________</span>
<a href="../ListOfTypes.html#Double_t">Double_t</a> <a href="../TUCNGeoTubeSeg.html">TUCNGeoTubeSeg</a>::<a href="../TUCNGeoTubeSeg.html#TUCNGeoTubeSeg:Capacity" title="Double_t TUCNGeoTubeSeg::Capacity() or overloads">Capacity</a>() <span class="keyword">const</span>
{
<span class="comment">// Computes capacity of the shape in [length^3]</span>
   <span class="keyword">return</span> <a href="../TUCNGeoTubeSeg.html">TUCNGeoTubeSeg</a>::<a href="../TUCNGeoTubeSeg.html#TUCNGeoTubeSeg:Capacity" title="Double_t TUCNGeoTubeSeg::Capacity() or overloads">Capacity</a>(fRmin,fRmax,fDz,fPhi1,fPhi2);
}   

<span class="comment">//_____________________________________________________________________________</span>
<a href="../ListOfTypes.html#Double_t">Double_t</a> <a href="../TUCNGeoTubeSeg.html">TUCNGeoTubeSeg</a>::<a href="../TUCNGeoTubeSeg.html#TUCNGeoTubeSeg:Capacity" title="Double_t TUCNGeoTubeSeg::Capacity() or overloads">Capacity</a>(<a href="../ListOfTypes.html#Double_t">Double_t</a> rmin, <a href="../ListOfTypes.html#Double_t">Double_t</a> rmax, <a href="../ListOfTypes.html#Double_t">Double_t</a> dz, <a href="../ListOfTypes.html#Double_t">Double_t</a> phi1, <a href="../ListOfTypes.html#Double_t">Double_t</a> phi2)
{
<span class="comment">// Computes capacity of the shape in [length^3]</span>
   <a href="../ListOfTypes.html#Double_t">Double_t</a> capacity = TMath::Abs(phi2-phi1)*TMath::DegToRad()*(rmax*rmax-rmin*rmin)*dz;
   <span class="keyword">return</span> capacity;
}   

<span class="comment">//_____________________________________________________________________________</span>
<span class="keyword">void</span> <a href="../TUCNGeoTubeSeg.html">TUCNGeoTubeSeg</a>::<a href="../TUCNGeoTubeSeg.html#TUCNGeoTubeSeg:ComputeBBox" title="void TUCNGeoTubeSeg::ComputeBBox()">ComputeBBox</a>()
{
<span class="comment">// compute bounding box of the tube segment</span>
   <a href="../ListOfTypes.html#Double_t">Double_t</a> xc[4];
   <a href="../ListOfTypes.html#Double_t">Double_t</a> yc[4];
   xc[0] = fRmax*TMath::Cos(fPhi1*TMath::DegToRad());
   yc[0] = fRmax*TMath::Sin(fPhi1*TMath::DegToRad());
   xc[1] = fRmax*TMath::Cos(fPhi2*TMath::DegToRad());
   yc[1] = fRmax*TMath::Sin(fPhi2*TMath::DegToRad());
   xc[2] = fRmin*TMath::Cos(fPhi1*TMath::DegToRad());
   yc[2] = fRmin*TMath::Sin(fPhi1*TMath::DegToRad());
   xc[3] = fRmin*TMath::Cos(fPhi2*TMath::DegToRad());
   yc[3] = fRmin*TMath::Sin(fPhi2*TMath::DegToRad());

   <a href="../ListOfTypes.html#Double_t">Double_t</a> xmin = xc[TMath::LocMin(4, &amp;xc[0])];
   <a href="../ListOfTypes.html#Double_t">Double_t</a> xmax = xc[TMath::LocMax(4, &amp;xc[0])];
   <a href="../ListOfTypes.html#Double_t">Double_t</a> ymin = yc[TMath::LocMin(4, &amp;yc[0])];
   <a href="../ListOfTypes.html#Double_t">Double_t</a> ymax = yc[TMath::LocMax(4, &amp;yc[0])];

   <a href="../ListOfTypes.html#Double_t">Double_t</a> dp = fPhi2-fPhi1;
   <span class="keyword">if</span> (dp&lt;0) dp+=360;
   <a href="../ListOfTypes.html#Double_t">Double_t</a> ddp = -fPhi1;
   <span class="keyword">if</span> (ddp&lt;0) ddp+= 360;
   <span class="keyword">if</span> (ddp&gt;360) ddp-=360;
   <span class="keyword">if</span> (ddp&lt;=dp) xmax = fRmax;
   ddp = 90-fPhi1;
   <span class="keyword">if</span> (ddp&lt;0) ddp+= 360;
   <span class="keyword">if</span> (ddp&gt;360) ddp-=360;
   <span class="keyword">if</span> (ddp&lt;=dp) ymax = fRmax;
   ddp = 180-fPhi1;
   <span class="keyword">if</span> (ddp&lt;0) ddp+= 360;
   <span class="keyword">if</span> (ddp&gt;360) ddp-=360;
   <span class="keyword">if</span> (ddp&lt;=dp) xmin = -fRmax;
   ddp = 270-fPhi1;
   <span class="keyword">if</span> (ddp&lt;0) ddp+= 360;
   <span class="keyword">if</span> (ddp&gt;360) ddp-=360;
   <span class="keyword">if</span> (ddp&lt;=dp) ymin = -fRmax;
   fOrigin[0] = (xmax+xmin)/2;
   fOrigin[1] = (ymax+ymin)/2;
   fOrigin[2] = 0;
   fDX = (xmax-xmin)/2;
   fDY = (ymax-ymin)/2;
   fDZ = fDz;
}

<span class="comment">//_____________________________________________________________________________</span>
<span class="keyword">void</span> <a href="../TUCNGeoTubeSeg.html">TUCNGeoTubeSeg</a>::<a href="../TUCNGeoTubeSeg.html#TUCNGeoTubeSeg:ComputeNormal" title="void TUCNGeoTubeSeg::ComputeNormal(Double_t* point,Double_t* dir,Double_t* norm)">ComputeNormal</a>(<a href="../ListOfTypes.html#Double_t">Double_t</a> *point, <a href="../ListOfTypes.html#Double_t">Double_t</a> *dir, <a href="../ListOfTypes.html#Double_t">Double_t</a> *norm)
{
<span class="comment">// Compute normal to closest surface from POINT.</span>
   <a href="../ListOfTypes.html#Double_t">Double_t</a> saf[3];
   <a href="../ListOfTypes.html#Double_t">Double_t</a> rsq = point[0]*point[0]+point[1]*point[1];
   <a href="../ListOfTypes.html#Double_t">Double_t</a> r = TMath::Sqrt(rsq);
   <a href="../ListOfTypes.html#Double_t">Double_t</a> c1 = TMath::Cos(fPhi1*TMath::DegToRad());
   <a href="../ListOfTypes.html#Double_t">Double_t</a> s1 = TMath::Sin(fPhi1*TMath::DegToRad());
   <a href="../ListOfTypes.html#Double_t">Double_t</a> c2 = TMath::Cos(fPhi2*TMath::DegToRad());
   <a href="../ListOfTypes.html#Double_t">Double_t</a> s2 = TMath::Sin(fPhi2*TMath::DegToRad());
   saf[0] = TMath::Abs(fDz-TMath::Abs(point[2]));
   saf[1] = (fRmin&gt;1E-10)?TMath::Abs(r-fRmin):TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
   saf[2] = TMath::Abs(fRmax-r);
   <a href="../ListOfTypes.html#Int_t">Int_t</a> i = TMath::LocMin(3,saf);
   <span class="keyword">if</span> (((fPhi2-fPhi1)&lt;360.) &amp;&amp; TGeoShape::<a href="../#TGeoShape:IsCloseToPhi" title="Bool_t TGeoShape::IsCloseToPhi(Double_t epsil,Double_t* point,Double_t c1,Double_t s1,Double_t c2,Double_t s2)">IsCloseToPhi</a>(saf[i], point,c1,s1,c2,s2)) {
      TGeoShape::<a href="../#TGeoShape:NormalPhi" title="void TGeoShape::NormalPhi(Double_t* point,Double_t* dir,Double_t* norm,Double_t c1,Double_t s1,Double_t c2,Double_t s2)">NormalPhi</a>(point,dir,norm,c1,s1,c2,s2);
      <span class="keyword">return</span>;
   }
   <span class="keyword">if</span> (i==0) {
      norm[0] = norm[1] = 0.;
      norm[2] = TMath::Sign(1.,dir[2]);
      <span class="keyword">return</span>;
   }
   norm[2] = 0;
   <a href="../ListOfTypes.html#Double_t">Double_t</a> phi = TMath::ATan2(point[1], point[0]);
   norm[0] = TMath::Cos(phi);
   norm[1] = TMath::Sin(phi);
   <span class="keyword">if</span> (norm[0]*dir[0]+norm[1]*dir[1]&lt;0) {
      norm[0] = -norm[0];
      norm[1] = -norm[1];
   }
}

<span class="comment">//_____________________________________________________________________________</span>
<span class="keyword">void</span> <a href="../TUCNGeoTubeSeg.html">TUCNGeoTubeSeg</a>::<a href="../TUCNGeoTubeSeg.html#TUCNGeoTubeSeg:ComputeNormalS" title="void TUCNGeoTubeSeg::ComputeNormalS(Double_t* point,Double_t* dir,Double_t* norm,Double_t rmin,Double_t rmax,Double_t dz,Double_t c1,Double_t s1,Double_t c2,Double_t s2)">ComputeNormalS</a>(<a href="../ListOfTypes.html#Double_t">Double_t</a> *point, <a href="../ListOfTypes.html#Double_t">Double_t</a> *dir, <a href="../ListOfTypes.html#Double_t">Double_t</a> *norm,
                                 <a href="../ListOfTypes.html#Double_t">Double_t</a> rmin, <a href="../ListOfTypes.html#Double_t">Double_t</a> rmax, <a href="../ListOfTypes.html#Double_t">Double_t</a> <span class="comment">/*dz*/</span>,
                                 <a href="../ListOfTypes.html#Double_t">Double_t</a> c1, <a href="../ListOfTypes.html#Double_t">Double_t</a> s1, <a href="../ListOfTypes.html#Double_t">Double_t</a> c2, <a href="../ListOfTypes.html#Double_t">Double_t</a> s2)
{
<span class="comment">// Compute normal to closest surface from POINT.</span>
   <a href="../ListOfTypes.html#Double_t">Double_t</a> saf[2];
   <a href="../ListOfTypes.html#Double_t">Double_t</a> rsq = point[0]*point[0]+point[1]*point[1];
   <a href="../ListOfTypes.html#Double_t">Double_t</a> r = TMath::Sqrt(rsq);
   saf[0] = (rmin&gt;1E-10)?TMath::Abs(r-rmin):TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
   saf[1] = TMath::Abs(rmax-r);
   <a href="../ListOfTypes.html#Int_t">Int_t</a> i = TMath::LocMin(2,saf);
   <span class="keyword">if</span> (TGeoShape::<a href="../#TGeoShape:IsCloseToPhi" title="Bool_t TGeoShape::IsCloseToPhi(Double_t epsil,Double_t* point,Double_t c1,Double_t s1,Double_t c2,Double_t s2)">IsCloseToPhi</a>(saf[i], point,c1,s1,c2,s2)) {
      TGeoShape::<a href="../#TGeoShape:NormalPhi" title="void TGeoShape::NormalPhi(Double_t* point,Double_t* dir,Double_t* norm,Double_t c1,Double_t s1,Double_t c2,Double_t s2)">NormalPhi</a>(point,dir,norm,c1,s1,c2,s2);
      <span class="keyword">return</span>;
   }
   norm[2] = 0;
   <a href="../ListOfTypes.html#Double_t">Double_t</a> phi = TMath::ATan2(point[1], point[0]);
   norm[0] = TMath::Cos(phi);
   norm[1] = TMath::Sin(phi);
   <span class="keyword">if</span> (norm[0]*dir[0]+norm[1]*dir[1]&lt;0) {
      norm[0] = -norm[0];
      norm[1] = -norm[1];
   }
}

<span class="comment">//_____________________________________________________________________________</span>
<a href="../ListOfTypes.html#Bool_t">Bool_t</a> <a href="../TUCNGeoTubeSeg.html">TUCNGeoTubeSeg</a>::<a href="../TUCNGeoTubeSeg.html#TUCNGeoTubeSeg:Contains" title="Bool_t TUCNGeoTubeSeg::Contains(Double_t* point)">Contains</a>(<a href="../ListOfTypes.html#Double_t">Double_t</a> *point) <span class="keyword">const</span>
{
<span class="comment">// test if point is inside this tube segment</span>
   <span class="comment">// first check if point is inside the tube</span>
   <span class="keyword">if</span> (!<a href="../TUCNGeoTube.html">TUCNGeoTube</a>::<a href="../TUCNGeoTube.html#TUCNGeoTube:Contains" title="Bool_t TUCNGeoTube::Contains(Double_t* point)">Contains</a>(point)) <span class="keyword">return</span> <a href="../ListOfTypes.html#Bool_t">kFALSE</a>;
   <span class="keyword">return</span> <a href="../#TGeoShape:IsInPhiRange" title="Bool_t TGeoShape::IsInPhiRange(Double_t* point,Double_t phi1,Double_t phi2)">IsInPhiRange</a>(point, fPhi1, fPhi2);
}

<span class="comment">//_____________________________________________________________________________</span>
<a href="../ListOfTypes.html#Int_t">Int_t</a> <a href="../TUCNGeoTubeSeg.html">TUCNGeoTubeSeg</a>::<a href="../TUCNGeoTubeSeg.html#TUCNGeoTubeSeg:DistancetoPrimitive" title="Int_t TUCNGeoTubeSeg::DistancetoPrimitive(Int_t px,Int_t py)">DistancetoPrimitive</a>(<a href="../ListOfTypes.html#Int_t">Int_t</a> px, <a href="../ListOfTypes.html#Int_t">Int_t</a> py)
{
<span class="comment">// compute closest distance from point px,py to each corner</span>
   <a href="../ListOfTypes.html#Int_t">Int_t</a> n = gGeoManager-&gt;GetNsegments()+1;
   <span class="keyword">const</span> <a href="../ListOfTypes.html#Int_t">Int_t</a> numPoints = 4*n;
   <span class="keyword">return</span> <a href="../#TGeoShape:ShapeDistancetoPrimitive" title="Int_t TGeoShape::ShapeDistancetoPrimitive(Int_t numpoints,Int_t px,Int_t py)">ShapeDistancetoPrimitive</a>(numPoints, px, py);
}

<span class="comment">//_____________________________________________________________________________</span>
<a href="../ListOfTypes.html#Double_t">Double_t</a> <a href="../TUCNGeoTubeSeg.html">TUCNGeoTubeSeg</a>::<a href="../TUCNGeoTubeSeg.html#TUCNGeoTubeSeg:DistFromInsideS" title="Double_t TUCNGeoTubeSeg::DistFromInsideS(Double_t* point,Double_t* dir,Double_t rmin,Double_t rmax,Double_t dz,Double_t c1,Double_t s1,Double_t c2,Double_t s2,Double_t cm,Double_t sm,Double_t cdfi)">DistFromInsideS</a>(<a href="../ListOfTypes.html#Double_t">Double_t</a> *point, <a href="../ListOfTypes.html#Double_t">Double_t</a> *dir, <a href="../ListOfTypes.html#Double_t">Double_t</a> rmin, <a href="../ListOfTypes.html#Double_t">Double_t</a> rmax, <a href="../ListOfTypes.html#Double_t">Double_t</a> dz,
                                 <a href="../ListOfTypes.html#Double_t">Double_t</a> c1, <a href="../ListOfTypes.html#Double_t">Double_t</a> s1, <a href="../ListOfTypes.html#Double_t">Double_t</a> c2, <a href="../ListOfTypes.html#Double_t">Double_t</a> s2, <a href="../ListOfTypes.html#Double_t">Double_t</a> cm, <a href="../ListOfTypes.html#Double_t">Double_t</a> sm, <a href="../ListOfTypes.html#Double_t">Double_t</a> cdfi)
{
<span class="comment">// Compute distance from inside point to surface of the tube segment (static)</span>
<span class="comment">// Boundary safe algorithm.</span>
   <span class="comment">// Do Z</span>
   <a href="../ListOfTypes.html#Double_t">Double_t</a> stube = <a href="../TUCNGeoTube.html">TUCNGeoTube</a>::<a href="../TUCNGeoTube.html#TUCNGeoTube:DistFromInsideS" title="Double_t TUCNGeoTube::DistFromInsideS(Double_t* point,Double_t* dir,Double_t rmin,Double_t rmax,Double_t dz)">DistFromInsideS</a>(point,dir,rmin,rmax,dz);
   <span class="keyword">if</span> (stube&lt;=0) <span class="keyword">return</span> 0.0;
   <a href="../ListOfTypes.html#Double_t">Double_t</a> sfmin = TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
   <a href="../ListOfTypes.html#Double_t">Double_t</a> rsq = point[0]*point[0]+point[1]*point[1];
   <a href="../ListOfTypes.html#Double_t">Double_t</a> r = TMath::Sqrt(rsq);
   <a href="../ListOfTypes.html#Double_t">Double_t</a> cpsi=point[0]*cm+point[1]*sm;
   <span class="keyword">if</span> (cpsi&gt;r*cdfi+TGeoShape::<a href="../#TGeoShape:Tolerance" title="Double_t TGeoShape::Tolerance()">Tolerance</a>())  {
      sfmin = TGeoShape::<a href="../#TGeoShape:DistToPhiMin" title="Double_t TGeoShape::DistToPhiMin(Double_t* point,Double_t* dir,Double_t s1,Double_t c1,Double_t s2,Double_t c2,Double_t sm,Double_t cm,Bool_t in=kTRUE)">DistToPhiMin</a>(point, dir, s1, c1, s2, c2, sm, cm);
      <span class="keyword">return</span> TMath::Min(stube,sfmin);
   }
   <span class="comment">// Point on the phi boundary or outside</span>
   <span class="comment">// which one: phi1 or phi2</span>
   <a href="../ListOfTypes.html#Double_t">Double_t</a> ddotn, xi, yi;
   <span class="keyword">if</span> (TMath::Abs(point[1]-s1*r) &lt; TMath::Abs(point[1]-s2*r)) {
      ddotn = s1*dir[0]-c1*dir[1];
      <span class="keyword">if</span> (ddotn&gt;=0) <span class="keyword">return</span> 0.0;
      ddotn = -s2*dir[0]+c2*dir[1];
      <span class="keyword">if</span> (ddotn&lt;=0) <span class="keyword">return</span> stube;
      sfmin = s2*point[0]-c2*point[1];
      <span class="keyword">if</span> (sfmin&lt;=0) <span class="keyword">return</span> stube;
      sfmin /= ddotn;
      <span class="keyword">if</span> (sfmin &gt;= stube) <span class="keyword">return</span> stube;
      xi = point[0]+sfmin*dir[0];
      yi = point[1]+sfmin*dir[1];
      <span class="keyword">if</span> (yi*cm-xi*sm&lt;0) <span class="keyword">return</span> stube;
      <span class="keyword">return</span> sfmin;
   }
   ddotn = -s2*dir[0]+c2*dir[1];
   <span class="keyword">if</span> (ddotn&gt;=0) <span class="keyword">return</span> 0.0;
   ddotn = s1*dir[0]-c1*dir[1];
   <span class="keyword">if</span> (ddotn&lt;=0) <span class="keyword">return</span> stube;
   sfmin = -s1*point[0]+c1*point[1];
   <span class="keyword">if</span> (sfmin&lt;=0) <span class="keyword">return</span> stube;
   sfmin /= ddotn;
   <span class="keyword">if</span> (sfmin &gt;= stube) <span class="keyword">return</span> stube;
   xi = point[0]+sfmin*dir[0];
   yi = point[1]+sfmin*dir[1];
   <span class="keyword">if</span> (yi*cm-xi*sm&gt;0) <span class="keyword">return</span> stube;
   <span class="keyword">return</span> sfmin;
}

<span class="comment">//_____________________________________________________________________________</span>
<a href="../ListOfTypes.html#Double_t">Double_t</a> <a href="../TUCNGeoTubeSeg.html">TUCNGeoTubeSeg</a>::<a href="../TUCNGeoTubeSeg.html#TUCNGeoTubeSeg:DistFromInside" title="Double_t TUCNGeoTubeSeg::DistFromInside(Double_t* point,Double_t* dir,Int_t iact=1,Double_t step=TGeoShape::Big(),Double_t* safe=0)">DistFromInside</a>(<a href="../ListOfTypes.html#Double_t">Double_t</a> *point, <a href="../ListOfTypes.html#Double_t">Double_t</a> *dir, <a href="../ListOfTypes.html#Int_t">Int_t</a> iact, <a href="../ListOfTypes.html#Double_t">Double_t</a> step, <a href="../ListOfTypes.html#Double_t">Double_t</a> *safe) <span class="keyword">const</span>
{
<span class="comment">// Compute distance from inside point to surface of the tube segment</span>
<span class="comment">// Boundary safe algorithm.</span>
   <span class="keyword">if</span> (iact&lt;3 &amp;&amp; safe) {
      *safe = <a href="../TUCNGeoTubeSeg.html#TUCNGeoTubeSeg:SafetyS" title="Double_t TUCNGeoTubeSeg::SafetyS(Double_t* point,Bool_t in,Double_t rmin,Double_t rmax,Double_t dz,Double_t phi1,Double_t phi2,Int_t skipz=0)">SafetyS</a>(point, <a href="../ListOfTypes.html#Bool_t">kTRUE</a>, fRmin, fRmax, fDz, fPhi1, fPhi2);
      <span class="keyword">if</span> (iact==0) <span class="keyword">return</span> TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
      <span class="keyword">if</span> ((iact==1) &amp;&amp; (*safe&gt;step)) <span class="keyword">return</span> TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
   }
   <span class="keyword">if</span> ((fPhi2-fPhi1)&gt;=360.) <span class="keyword">return</span> <a href="../TUCNGeoTube.html">TUCNGeoTube</a>::<a href="../TUCNGeoTube.html#TUCNGeoTube:DistFromInsideS" title="Double_t TUCNGeoTube::DistFromInsideS(Double_t* point,Double_t* dir,Double_t rmin,Double_t rmax,Double_t dz)">DistFromInsideS</a>(point,dir,fRmin,fRmax,fDz);
   <a href="../ListOfTypes.html#Double_t">Double_t</a> phi1 = fPhi1*TMath::DegToRad();
   <a href="../ListOfTypes.html#Double_t">Double_t</a> phi2 = fPhi2*TMath::DegToRad();
   <a href="../ListOfTypes.html#Double_t">Double_t</a> c1 = TMath::Cos(phi1);
   <a href="../ListOfTypes.html#Double_t">Double_t</a> c2 = TMath::Cos(phi2);
   <a href="../ListOfTypes.html#Double_t">Double_t</a> s1 = TMath::Sin(phi1);
   <a href="../ListOfTypes.html#Double_t">Double_t</a> s2 = TMath::Sin(phi2);
   <a href="../ListOfTypes.html#Double_t">Double_t</a> phim = 0.5*(phi1+phi2);
   <a href="../ListOfTypes.html#Double_t">Double_t</a> cm = TMath::Cos(phim);
   <a href="../ListOfTypes.html#Double_t">Double_t</a> sm = TMath::Sin(phim);
   <a href="../ListOfTypes.html#Double_t">Double_t</a> dfi = 0.5*(phi2-phi1);
   <a href="../ListOfTypes.html#Double_t">Double_t</a> cdfi = TMath::Cos(dfi);

   <span class="comment">// compute distance to surface</span>
   <span class="keyword">return</span> <a href="../TUCNGeoTubeSeg.html">TUCNGeoTubeSeg</a>::<a href="../TUCNGeoTubeSeg.html#TUCNGeoTubeSeg:DistFromInsideS" title="Double_t TUCNGeoTubeSeg::DistFromInsideS(Double_t* point,Double_t* dir,Double_t rmin,Double_t rmax,Double_t dz,Double_t c1,Double_t s1,Double_t c2,Double_t s2,Double_t cm,Double_t sm,Double_t cdfi)">DistFromInsideS</a>(point,dir,fRmin,fRmax,fDz,c1,s1,c2,s2,cm,sm,cdfi);
}

<span class="comment">//_____________________________________________________________________________</span>
<a href="../ListOfTypes.html#Double_t">Double_t</a> <a href="../TUCNGeoTubeSeg.html">TUCNGeoTubeSeg</a>::<a href="../TUCNGeoTubeSeg.html#TUCNGeoTubeSeg:DistFromOutsideS" title="Double_t TUCNGeoTubeSeg::DistFromOutsideS(Double_t* point,Double_t* dir,Double_t rmin,Double_t rmax,Double_t dz,Double_t c1,Double_t s1,Double_t c2,Double_t s2,Double_t cm,Double_t sm,Double_t cdfi)">DistFromOutsideS</a>(<a href="../ListOfTypes.html#Double_t">Double_t</a> *point, <a href="../ListOfTypes.html#Double_t">Double_t</a> *dir, <a href="../ListOfTypes.html#Double_t">Double_t</a> rmin, <a href="../ListOfTypes.html#Double_t">Double_t</a> rmax,
                                <a href="../ListOfTypes.html#Double_t">Double_t</a> dz, <a href="../ListOfTypes.html#Double_t">Double_t</a> c1, <a href="../ListOfTypes.html#Double_t">Double_t</a> s1, <a href="../ListOfTypes.html#Double_t">Double_t</a> c2, <a href="../ListOfTypes.html#Double_t">Double_t</a> s2,
                                <a href="../ListOfTypes.html#Double_t">Double_t</a> cm, <a href="../ListOfTypes.html#Double_t">Double_t</a> sm, <a href="../ListOfTypes.html#Double_t">Double_t</a> cdfi)
{
<span class="comment">// Static method to compute distance to arbitrary tube segment from outside point</span>
<span class="comment">// Boundary safe algorithm.</span>
   <a href="../ListOfTypes.html#Double_t">Double_t</a> r2, cpsi;
   <span class="comment">// check Z planes</span>
   <a href="../ListOfTypes.html#Double_t">Double_t</a> xi, yi, zi;
   zi = dz - TMath::Abs(point[2]);
   <a href="../ListOfTypes.html#Double_t">Double_t</a> rmaxsq = rmax*rmax;
   <a href="../ListOfTypes.html#Double_t">Double_t</a> rminsq = rmin*rmin;
   <a href="../ListOfTypes.html#Double_t">Double_t</a> s = TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
   <a href="../ListOfTypes.html#Double_t">Double_t</a> snxt=TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
   <a href="../ListOfTypes.html#Bool_t">Bool_t</a> in = <a href="../ListOfTypes.html#Bool_t">kFALSE</a>;
   <a href="../ListOfTypes.html#Bool_t">Bool_t</a> inz = (zi&lt;0)?<a href="../ListOfTypes.html#Bool_t">kFALSE</a>:<a href="../ListOfTypes.html#Bool_t">kTRUE</a>;
   <span class="keyword">if</span> (!inz) {
      <span class="keyword">if</span> (point[2]*dir[2]&gt;=0) <span class="keyword">return</span> TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
      s = -zi/TMath::Abs(dir[2]);
      xi = point[0]+s*dir[0];
      yi = point[1]+s*dir[1];
      r2=xi*xi+yi*yi;
      <span class="keyword">if</span> ((rminsq&lt;=r2) &amp;&amp; (r2&lt;=rmaxsq)) {
         cpsi=(xi*cm+yi*sm)/TMath::Sqrt(r2);
         <span class="keyword">if</span> (cpsi&gt;=cdfi) <span class="keyword">return</span> s;
      }
   }

   <span class="comment">// check outer cyl. surface</span>
   <a href="../ListOfTypes.html#Double_t">Double_t</a> rsq = point[0]*point[0]+point[1]*point[1];
   <a href="../ListOfTypes.html#Double_t">Double_t</a> r = TMath::Sqrt(rsq);
   <a href="../ListOfTypes.html#Double_t">Double_t</a> nsq=dir[0]*dir[0]+dir[1]*dir[1];
   <a href="../ListOfTypes.html#Double_t">Double_t</a> rdotn=point[0]*dir[0]+point[1]*dir[1];
   <a href="../ListOfTypes.html#Double_t">Double_t</a> b,d;
   <a href="../ListOfTypes.html#Bool_t">Bool_t</a> inrmax = <a href="../ListOfTypes.html#Bool_t">kFALSE</a>;
   <a href="../ListOfTypes.html#Bool_t">Bool_t</a> inrmin = <a href="../ListOfTypes.html#Bool_t">kFALSE</a>;
   <a href="../ListOfTypes.html#Bool_t">Bool_t</a> inphi  = <a href="../ListOfTypes.html#Bool_t">kFALSE</a>;
   <span class="keyword">if</span> (rsq&lt;=rmaxsq+TGeoShape::<a href="../#TGeoShape:Tolerance" title="Double_t TGeoShape::Tolerance()">Tolerance</a>()) inrmax = <a href="../ListOfTypes.html#Bool_t">kTRUE</a>;
   <span class="keyword">if</span> (rsq&gt;=rminsq-TGeoShape::<a href="../#TGeoShape:Tolerance" title="Double_t TGeoShape::Tolerance()">Tolerance</a>()) inrmin = <a href="../ListOfTypes.html#Bool_t">kTRUE</a>;
   cpsi=point[0]*cm+point[1]*sm;
   <span class="keyword">if</span> (cpsi&gt;r*cdfi-TGeoShape::<a href="../#TGeoShape:Tolerance" title="Double_t TGeoShape::Tolerance()">Tolerance</a>())  inphi = <a href="../ListOfTypes.html#Bool_t">kTRUE</a>;
   in = inz &amp; inrmin &amp; inrmax &amp; inphi;
   <span class="comment">// If inside, we are most likely on a boundary within machine precision.</span>
   <span class="keyword">if</span> (in) {
      <a href="../ListOfTypes.html#Bool_t">Bool_t</a> checkout = <a href="../ListOfTypes.html#Bool_t">kFALSE</a>;
      <a href="../ListOfTypes.html#Double_t">Double_t</a> safphi = (cpsi-r*cdfi)*TMath::Sqrt(1.-cdfi*cdfi);
<span class="comment">//      <a href="../ListOfTypes.html#Double_t">Double_t</a> sch, cch;</span>
      <span class="comment">// check if on Z boundaries</span>
      <span class="keyword">if</span> (zi&lt;rmax-r) {
         <span class="keyword">if</span> ((rmin==0) || (zi&lt;r-rmin)) {
            <span class="keyword">if</span> (zi&lt;safphi) {
               <span class="keyword">if</span> (point[2]*dir[2]&lt;0) <span class="keyword">return</span> 0.0;
               <span class="keyword">return</span> TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
            }
         }
      }
      <span class="keyword">if</span> ((rmaxsq-rsq) &lt; (rsq-rminsq)) checkout = <a href="../ListOfTypes.html#Bool_t">kTRUE</a>;
      <span class="comment">// check if on Rmax boundary</span>
      <span class="keyword">if</span> (checkout &amp;&amp; (rmax-r&lt;safphi)) {
         <span class="keyword">if</span> (rdotn&gt;=0) <span class="keyword">return</span> TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
         <span class="keyword">return</span> 0.0;
      }
      <span class="keyword">if</span> (TMath::Abs(nsq)&lt;TGeoShape::<a href="../#TGeoShape:Tolerance" title="Double_t TGeoShape::Tolerance()">Tolerance</a>()) <span class="keyword">return</span> TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
      <span class="comment">// check if on phi boundary</span>
      <span class="keyword">if</span> ((rmin==0) || (safphi&lt;r-rmin)) {
         <span class="comment">// We may cross again a phi of rmin boundary</span>
         <span class="comment">// check first if we are on phi1 or phi2</span>
         <a href="../ListOfTypes.html#Double_t">Double_t</a> un;
         <span class="keyword">if</span> (TMath::Abs(point[1]-s1*r) &lt; TMath::Abs(point[1]-s2*r)) {
            un = dir[0]*s1-dir[1]*c1;
            <span class="keyword">if</span> (un &lt; 0) <span class="keyword">return</span> 0.0;
            <span class="keyword">if</span> (cdfi&gt;=0) <span class="keyword">return</span> TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
            un = -dir[0]*s2+dir[1]*c2;
            <span class="keyword">if</span> (un&lt;0) {
               s = -point[0]*s2+point[1]*c2;
               <span class="keyword">if</span> (s&gt;0) {
                  s /= (-un);
                  zi = point[2]+s*dir[2];
                  <span class="keyword">if</span> (TMath::Abs(zi)&lt;=dz) {
                     xi = point[0]+s*dir[0];
                     yi = point[1]+s*dir[1];
                     r2=xi*xi+yi*yi;
                     <span class="keyword">if</span> ((rminsq&lt;=r2) &amp;&amp; (r2&lt;=rmaxsq)) {
                        <span class="keyword">if</span> ((yi*cm-xi*sm)&gt;0) <span class="keyword">return</span> s;
                     }
                  }
               }
            }
         } <span class="keyword">else</span> {
            un = -dir[0]*s2+dir[1]*c2;
            <span class="keyword">if</span> (un &lt; 0) <span class="keyword">return</span> 0.0;
            <span class="keyword">if</span> (cdfi&gt;=0) <span class="keyword">return</span> TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
            un = dir[0]*s1-dir[1]*c1;
            <span class="keyword">if</span> (un&lt;0) {
               s = point[0]*s1-point[1]*c1;
               <span class="keyword">if</span> (s&gt;0) {
                  s /= (-un);
                  zi = point[2]+s*dir[2];
                  <span class="keyword">if</span> (TMath::Abs(zi)&lt;=dz) {
                     xi = point[0]+s*dir[0];
                     yi = point[1]+s*dir[1];
                     r2=xi*xi+yi*yi;
                     <span class="keyword">if</span> ((rminsq&lt;=r2) &amp;&amp; (r2&lt;=rmaxsq)) {
                        <span class="keyword">if</span> ((yi*cm-xi*sm)&lt;0) <span class="keyword">return</span> s;
                     }
                  }
               }
            }
         }
         <span class="comment">// We may also cross rmin, (+) solution</span>
         <span class="keyword">if</span> (rdotn&gt;=0) <span class="keyword">return</span> TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
         <span class="keyword">if</span> (cdfi&gt;=0) <span class="keyword">return</span> TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
         <a href="../TUCNGeoTube.html#TUCNGeoTube:DistToTube" title="void TUCNGeoTube::DistToTube(Double_t rsq,Double_t nsq,Double_t rdotn,Double_t radius,Double_t&amp; b,Double_t&amp; delta)">DistToTube</a>(rsq, nsq, rdotn, rmin, b, d);
         <span class="keyword">if</span> (d&gt;0) {
            s=-b+d;
            <span class="keyword">if</span> (s&gt;0) {
               zi=point[2]+s*dir[2];
               <span class="keyword">if</span> (TMath::Abs(zi)&lt;=dz) {
                  xi=point[0]+s*dir[0];
                  yi=point[1]+s*dir[1];
                  <span class="keyword">if</span> ((xi*cm+yi*sm) &gt;= rmin*cdfi) <span class="keyword">return</span> s;
               }
            }
         }
         <span class="keyword">return</span> TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
      }
      <span class="comment">// we are on rmin boundary: we may cross again rmin or a phi facette</span>
      <span class="keyword">if</span> (rdotn&gt;=0) <span class="keyword">return</span> 0.0;
      <a href="../TUCNGeoTube.html#TUCNGeoTube:DistToTube" title="void TUCNGeoTube::DistToTube(Double_t rsq,Double_t nsq,Double_t rdotn,Double_t radius,Double_t&amp; b,Double_t&amp; delta)">DistToTube</a>(rsq, nsq, rdotn, rmin, b, d);
      <span class="keyword">if</span> (d&gt;0) {
         s=-b+d;
         <span class="keyword">if</span> (s&gt;0) {
            zi=point[2]+s*dir[2];
            <span class="keyword">if</span> (TMath::Abs(zi)&lt;=dz) {
               <span class="comment">// now check phi range</span>
               xi=point[0]+s*dir[0];
               yi=point[1]+s*dir[1];
               r2=xi*xi+yi*yi;
               <span class="keyword">if</span> ((xi*cm+yi*sm) &gt;= rmin*cdfi) <span class="keyword">return</span> s;
               <span class="comment">// now we really have to check any phi crossing</span>
               <a href="../ListOfTypes.html#Double_t">Double_t</a> un=-dir[0]*s1+dir[1]*c1;
               <span class="keyword">if</span> (un &gt; 0) {
                  s=point[0]*s1-point[1]*c1;
                  <span class="keyword">if</span> (s&gt;=0) {
                     s /= un;
                     zi=point[2]+s*dir[2];
                     <span class="keyword">if</span> (TMath::Abs(zi)&lt;=dz) {
                        xi=point[0]+s*dir[0];
                        yi=point[1]+s*dir[1];
                        r2=xi*xi+yi*yi;
                        <span class="keyword">if</span> ((rminsq&lt;=r2) &amp;&amp; (r2&lt;=rmaxsq)) {
                           <span class="keyword">if</span> ((yi*cm-xi*sm)&lt;=0) {
                              <span class="keyword">if</span> (s&lt;snxt) snxt=s;
                           }
                        }
                     }
                  }
               }
               un=dir[0]*s2-dir[1]*c2;
               <span class="keyword">if</span> (un &gt; 0) {
                  s=(point[1]*c2-point[0]*s2)/un;
                  <span class="keyword">if</span> (s&gt;=0 &amp;&amp; s&lt;snxt) {
                     zi=point[2]+s*dir[2];
                     <span class="keyword">if</span> (TMath::Abs(zi)&lt;=dz) {
                        xi=point[0]+s*dir[0];
                        yi=point[1]+s*dir[1];
                        r2=xi*xi+yi*yi;
                        <span class="keyword">if</span> ((rminsq&lt;=r2) &amp;&amp; (r2&lt;=rmaxsq)) {
                           <span class="keyword">if</span> ((yi*cm-xi*sm)&gt;=0) {
                              <span class="keyword">return</span> s;
                           }
                        }
                     }
                  }
               }
               <span class="keyword">return</span> snxt;
            }
         }
      }
      <span class="keyword">return</span> TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
   }
   <span class="comment">// only r&gt;rmax has to be considered</span>
   <span class="keyword">if</span> (TMath::Abs(nsq)&lt;TGeoShape::<a href="../#TGeoShape:Tolerance" title="Double_t TGeoShape::Tolerance()">Tolerance</a>()) <span class="keyword">return</span> TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
   <span class="keyword">if</span> (rsq&gt;=rmax*rmax) {
      <span class="keyword">if</span> (rdotn&gt;=0) <span class="keyword">return</span> TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
      <a href="../TUCNGeoTube.html">TUCNGeoTube</a>::<a href="../TUCNGeoTube.html#TUCNGeoTube:DistToTube" title="void TUCNGeoTube::DistToTube(Double_t rsq,Double_t nsq,Double_t rdotn,Double_t radius,Double_t&amp; b,Double_t&amp; delta)">DistToTube</a>(rsq, nsq, rdotn, rmax, b, d);
      <span class="keyword">if</span> (d&gt;0) {
         s=-b-d;
         <span class="keyword">if</span> (s&gt;0) {
            zi=point[2]+s*dir[2];
            <span class="keyword">if</span> (TMath::Abs(zi)&lt;=dz) {
               xi=point[0]+s*dir[0];
               yi=point[1]+s*dir[1];
               cpsi = xi*cm+yi*sm;
               <span class="keyword">if</span> (cpsi&gt;=rmax*cdfi) <span class="keyword">return</span> s;
            }
         }
      }
   }
   <span class="comment">// check inner cylinder</span>
   <span class="keyword">if</span> (rmin&gt;0) {
      <a href="../TUCNGeoTube.html">TUCNGeoTube</a>::<a href="../TUCNGeoTube.html#TUCNGeoTube:DistToTube" title="void TUCNGeoTube::DistToTube(Double_t rsq,Double_t nsq,Double_t rdotn,Double_t radius,Double_t&amp; b,Double_t&amp; delta)">DistToTube</a>(rsq, nsq, rdotn, rmin, b, d);
      <span class="keyword">if</span> (d&gt;0) {
         s=-b+d;
         <span class="keyword">if</span> (s&gt;0) {
            zi=point[2]+s*dir[2];
            <span class="keyword">if</span> (TMath::Abs(zi)&lt;=dz) {
               xi=point[0]+s*dir[0];
               yi=point[1]+s*dir[1];
               cpsi = xi*cm+yi*sm;
               <span class="keyword">if</span> (cpsi&gt;=rmin*cdfi) snxt=s;
            }
         }
      }
   }
   <span class="comment">// check phi planes</span>
   <a href="../ListOfTypes.html#Double_t">Double_t</a> un=-dir[0]*s1+dir[1]*c1;
   <span class="keyword">if</span> (un &gt; 0) {
      s=point[0]*s1-point[1]*c1;
      <span class="keyword">if</span> (s&gt;=0) {
         s /= un;
         zi=point[2]+s*dir[2];
         <span class="keyword">if</span> (TMath::Abs(zi)&lt;=dz) {
            xi=point[0]+s*dir[0];
            yi=point[1]+s*dir[1];
            r2=xi*xi+yi*yi;
            <span class="keyword">if</span> ((rminsq&lt;=r2) &amp;&amp; (r2&lt;=rmaxsq)) {
               <span class="keyword">if</span> ((yi*cm-xi*sm)&lt;=0) {
                  <span class="keyword">if</span> (s&lt;snxt) snxt=s;
               }
            }
         }
      }
   }
   un=dir[0]*s2-dir[1]*c2;
   <span class="keyword">if</span> (un &gt; 0) {
      s=point[1]*c2-point[0]*s2;
      <span class="keyword">if</span> (s&gt;=0) {
         s /= un;
         zi=point[2]+s*dir[2];
         <span class="keyword">if</span> (TMath::Abs(zi)&lt;=dz) {
            xi=point[0]+s*dir[0];
            yi=point[1]+s*dir[1];
            r2=xi*xi+yi*yi;
            <span class="keyword">if</span> ((rminsq&lt;=r2) &amp;&amp; (r2&lt;=rmaxsq)) {
               <span class="keyword">if</span> ((yi*cm-xi*sm)&gt;=0) {
                  <span class="keyword">if</span> (s&lt;snxt) snxt=s;
               }
            }
         }
      }
   }
   <span class="keyword">return</span> snxt;
}

<span class="comment">//_____________________________________________________________________________</span>
<a href="../ListOfTypes.html#Double_t">Double_t</a> <a href="../TUCNGeoTubeSeg.html">TUCNGeoTubeSeg</a>::<a href="../TUCNGeoTubeSeg.html#TUCNGeoTubeSeg:DistFromOutside" title="Double_t TUCNGeoTubeSeg::DistFromOutside(Double_t* point,Double_t* dir,Int_t iact=1,Double_t step=TGeoShape::Big(),Double_t* safe=0)">DistFromOutside</a>(<a href="../ListOfTypes.html#Double_t">Double_t</a> *point, <a href="../ListOfTypes.html#Double_t">Double_t</a> *dir, <a href="../ListOfTypes.html#Int_t">Int_t</a> iact, <a href="../ListOfTypes.html#Double_t">Double_t</a> step, <a href="../ListOfTypes.html#Double_t">Double_t</a> *safe) <span class="keyword">const</span>
{
<span class="comment">// compute distance from outside point to surface of the tube segment</span>
   <span class="comment">// fist localize point w.r.t tube</span>
   <span class="keyword">if</span> (iact&lt;3 &amp;&amp; safe) {
      *safe = <a href="../TUCNGeoTubeSeg.html#TUCNGeoTubeSeg:SafetyS" title="Double_t TUCNGeoTubeSeg::SafetyS(Double_t* point,Bool_t in,Double_t rmin,Double_t rmax,Double_t dz,Double_t phi1,Double_t phi2,Int_t skipz=0)">SafetyS</a>(point, <a href="../ListOfTypes.html#Bool_t">kFALSE</a>, fRmin, fRmax, fDz, fPhi1, fPhi2);
      <span class="keyword">if</span> (iact==0) <span class="keyword">return</span> TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
      <span class="keyword">if</span> ((iact==1) &amp;&amp; (step&lt;=*safe)) <span class="keyword">return</span> TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
   }
<span class="comment">// Check if the bounding box is crossed within the requested distance</span>
   <a href="../ListOfTypes.html#Double_t">Double_t</a> sdist = <a href="../TUCNGeoBBox.html">TUCNGeoBBox</a>::<a href="../#TGeoBBox:DistFromOutside" title="Double_t TGeoBBox::DistFromOutside(Double_t* point,Double_t* dir,Int_t iact=1,Double_t step=TGeoShape::Big(),Double_t* safe=0) or overloads">DistFromOutside</a>(point,dir, fDX, fDY, fDZ, fOrigin, step);
   <span class="keyword">if</span> (sdist&gt;=step) <span class="keyword">return</span> TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
   <span class="keyword">if</span> ((fPhi2-fPhi1)&gt;=360.) <span class="keyword">return</span> <a href="../TUCNGeoTube.html">TUCNGeoTube</a>::<a href="../TUCNGeoTube.html#TUCNGeoTube:DistFromOutsideS" title="Double_t TUCNGeoTube::DistFromOutsideS(Double_t* point,Double_t* dir,Double_t rmin,Double_t rmax,Double_t dz)">DistFromOutsideS</a>(point,dir,fRmin,fRmax,fDz);
   <a href="../ListOfTypes.html#Double_t">Double_t</a> phi1 = fPhi1*TMath::DegToRad();
   <a href="../ListOfTypes.html#Double_t">Double_t</a> phi2 = fPhi2*TMath::DegToRad();
   <a href="../ListOfTypes.html#Double_t">Double_t</a> c1 = TMath::Cos(phi1);
   <a href="../ListOfTypes.html#Double_t">Double_t</a> s1 = TMath::Sin(phi1);
   <a href="../ListOfTypes.html#Double_t">Double_t</a> c2 = TMath::Cos(phi2);
   <a href="../ListOfTypes.html#Double_t">Double_t</a> s2 = TMath::Sin(phi2);
   <a href="../ListOfTypes.html#Double_t">Double_t</a> fio = 0.5*(phi1+phi2);
   <a href="../ListOfTypes.html#Double_t">Double_t</a> cm = TMath::Cos(fio);
   <a href="../ListOfTypes.html#Double_t">Double_t</a> sm = TMath::Sin(fio);
   <a href="../ListOfTypes.html#Double_t">Double_t</a> dfi = 0.5*(phi2-phi1);
   <a href="../ListOfTypes.html#Double_t">Double_t</a> cdfi = TMath::Cos(dfi);

   <span class="comment">// find distance to shape</span>
   <span class="keyword">return</span> <a href="../TUCNGeoTubeSeg.html">TUCNGeoTubeSeg</a>::<a href="../TUCNGeoTubeSeg.html#TUCNGeoTubeSeg:DistFromOutsideS" title="Double_t TUCNGeoTubeSeg::DistFromOutsideS(Double_t* point,Double_t* dir,Double_t rmin,Double_t rmax,Double_t dz,Double_t c1,Double_t s1,Double_t c2,Double_t s2,Double_t cm,Double_t sm,Double_t cdfi)">DistFromOutsideS</a>(point, dir, fRmin, fRmax, fDz, c1, s1, c2, s2, cm, sm, cdfi);
}

<span class="comment">//_____________________________________________________________________________</span>
TGeoVolume *<a href="../TUCNGeoTubeSeg.html">TUCNGeoTubeSeg</a>::<a href="../TUCNGeoTubeSeg.html#TUCNGeoTubeSeg:Divide" title="TGeoVolume* TUCNGeoTubeSeg::Divide(TGeoVolume* voldiv,const char* divname,Int_t iaxis,Int_t ndiv,Double_t start,Double_t step)">Divide</a>(TGeoVolume *voldiv, <span class="keyword">const</span> <span class="keyword">char</span> *divname, <a href="../ListOfTypes.html#Int_t">Int_t</a> iaxis, <a href="../ListOfTypes.html#Int_t">Int_t</a> ndiv,
                             <a href="../ListOfTypes.html#Double_t">Double_t</a> start, <a href="../ListOfTypes.html#Double_t">Double_t</a> step)
{
<span class="comment">//--- <a href="../TUCNGeoCtub.html#TUCNGeoCtub:Divide" title="TGeoVolume* TUCNGeoCtub::Divide(TGeoVolume* voldiv,const char* divname,Int_t iaxis,Int_t ndiv,Double_t start,Double_t step)">Divide</a> this tube segment shape belonging to volume <span class="string">"voldiv"</span> into ndiv volumes</span>
<span class="comment">// called divname, from start position with the given step. Returns pointer</span>
<span class="comment">// to created division cell volume in case of Z divisions. For radialdivision</span>
<span class="comment">// creates all volumes with different shapes and returns pointer to volume that</span>
<span class="comment">// was divided. In case a wrong division axis is supplied, returns pointer to</span>
<span class="comment">// volume that was divided.</span>
   TGeoShape *shape;           <span class="comment">//--- shape to be created</span>
   TGeoVolume *vol;            <span class="comment">//--- division volume to be created</span>
   TGeoVolumeMulti *vmulti;    <span class="comment">//--- generic divided volume</span>
   TGeoPatternFinder *finder;  <span class="comment">//--- finder to be attached</span>
   TString opt = <span class="string">""</span>;           <span class="comment">//--- option to be attached</span>
   <a href="../ListOfTypes.html#Double_t">Double_t</a> dphi;
   <a href="../ListOfTypes.html#Int_t">Int_t</a> id;
   <a href="../ListOfTypes.html#Double_t">Double_t</a> end = start+ndiv*step;
   <span class="keyword">switch</span> (iaxis) {
      <span class="keyword">case</span> 1:  <span class="comment">//---                 R division</span>
         finder = <span class="keyword">new</span> TGeoPatternCylR(voldiv, ndiv, start, end);
         vmulti = gGeoManager-&gt;MakeVolumeMulti(divname, voldiv-&gt;GetMedium());
         voldiv-&gt;SetFinder(finder);
         finder-&gt;SetDivIndex(voldiv-&gt;GetNdaughters());
         <span class="keyword">for</span> (id=0; id&lt;ndiv; id++) {
            shape = <span class="keyword">new</span> <a href="../TUCNGeoTubeSeg.html">TUCNGeoTubeSeg</a>(start+id*step, start+(id+1)*step, fDz, fPhi1, fPhi2);
            vol = <span class="keyword">new</span> TGeoVolume(divname, shape, voldiv-&gt;GetMedium());
            vmulti-&gt;AddVolume(vol);
            opt = <span class="string">"R"</span>;
            voldiv-&gt;AddNodeOffset(vol, id, 0, opt.Data());
            ((TGeoNodeOffset*)voldiv-&gt;GetNodes()-&gt;At(voldiv-&gt;GetNdaughters()-1))-&gt;SetFinder(finder);
         }
         <span class="keyword">return</span> vmulti;
      <span class="keyword">case</span> 2:  <span class="comment">//---                 Phi division</span>
         dphi = fPhi2-fPhi1;
         <span class="keyword">if</span> (dphi&lt;0) dphi+=360.;
         <span class="keyword">if</span> (step&lt;=0) {step=dphi/ndiv; start=fPhi1; end=fPhi2;}
         finder = <span class="keyword">new</span> TGeoPatternCylPhi(voldiv, ndiv, start, end);
         voldiv-&gt;SetFinder(finder);
         finder-&gt;SetDivIndex(voldiv-&gt;GetNdaughters());
         shape = <span class="keyword">new</span> <a href="../TUCNGeoTubeSeg.html">TUCNGeoTubeSeg</a>(fRmin, fRmax, fDz, -step/2, step/2);
         vol = <span class="keyword">new</span> TGeoVolume(divname, shape, voldiv-&gt;GetMedium());
         vmulti = gGeoManager-&gt;MakeVolumeMulti(divname, voldiv-&gt;GetMedium());
         vmulti-&gt;AddVolume(vol);
         opt = <span class="string">"Phi"</span>;
         <span class="keyword">for</span> (id=0; id&lt;ndiv; id++) {
            voldiv-&gt;AddNodeOffset(vol, id, start+id*step+step/2, opt.Data());
            ((TGeoNodeOffset*)voldiv-&gt;GetNodes()-&gt;At(voldiv-&gt;GetNdaughters()-1))-&gt;SetFinder(finder);
         }
         <span class="keyword">return</span> vmulti;
      <span class="keyword">case</span> 3: <span class="comment">//---                  Z division</span>
         finder = <span class="keyword">new</span> TGeoPatternZ(voldiv, ndiv, start, end);
         voldiv-&gt;SetFinder(finder);
         finder-&gt;SetDivIndex(voldiv-&gt;GetNdaughters());
         shape = <span class="keyword">new</span> <a href="../TUCNGeoTubeSeg.html">TUCNGeoTubeSeg</a>(fRmin, fRmax, step/2, fPhi1, fPhi2);
         vol = <span class="keyword">new</span> TGeoVolume(divname, shape, voldiv-&gt;GetMedium());
         vmulti = gGeoManager-&gt;MakeVolumeMulti(divname, voldiv-&gt;GetMedium());
         vmulti-&gt;AddVolume(vol);
         opt = <span class="string">"Z"</span>;
         <span class="keyword">for</span> (id=0; id&lt;ndiv; id++) {
            voldiv-&gt;AddNodeOffset(vol, id, start+step/2+id*step, opt.Data());
            ((TGeoNodeOffset*)voldiv-&gt;GetNodes()-&gt;At(voldiv-&gt;GetNdaughters()-1))-&gt;SetFinder(finder);
         }
         <span class="keyword">return</span> vmulti;
      <span class="keyword">default</span>:
         <a href="../#TObject:Error" title="void TObject::Error(const char* method,const char* msgfmt)">Error</a>(<span class="string">"Divide"</span>, <span class="string">"In shape %s wrong axis type for division"</span>, <a href="../#TGeoShape:GetName" title="const char* TGeoShape::GetName()">GetName</a>());
         <span class="keyword">return</span> 0;
   }
}

<span class="comment">//_____________________________________________________________________________</span>
<a href="../ListOfTypes.html#Double_t">Double_t</a> <a href="../TUCNGeoTubeSeg.html">TUCNGeoTubeSeg</a>::<a href="../TUCNGeoTubeSeg.html#TUCNGeoTubeSeg:GetAxisRange" title="Double_t TUCNGeoTubeSeg::GetAxisRange(Int_t iaxis,Double_t&amp; xlo,Double_t&amp; xhi)">GetAxisRange</a>(<a href="../ListOfTypes.html#Int_t">Int_t</a> iaxis, <a href="../ListOfTypes.html#Double_t">Double_t</a> &amp;xlo, <a href="../ListOfTypes.html#Double_t">Double_t</a> &amp;xhi) <span class="keyword">const</span>
{
<span class="comment">// Get range of shape for a given axis.</span>
   xlo = 0;
   xhi = 0;
   <a href="../ListOfTypes.html#Double_t">Double_t</a> dx = 0;
   <span class="keyword">switch</span> (iaxis) {
      <span class="keyword">case</span> 1:
         xlo = fRmin;
         xhi = fRmax;
         dx = xhi-xlo;
         <span class="keyword">return</span> dx;
      <span class="keyword">case</span> 2:
         xlo = fPhi1;
         xhi = fPhi2;
         dx = xhi-xlo;
         <span class="keyword">return</span> dx;
      <span class="keyword">case</span> 3:
         xlo = -fDz;
         xhi = fDz;
         dx = xhi-xlo;
         <span class="keyword">return</span> dx;
   }
   <span class="keyword">return</span> dx;
}

<span class="comment">//_____________________________________________________________________________</span>
<span class="keyword">void</span> <a href="../TUCNGeoTubeSeg.html">TUCNGeoTubeSeg</a>::<a href="../TUCNGeoTubeSeg.html#TUCNGeoTubeSeg:GetBoundingCylinder" title="void TUCNGeoTubeSeg::GetBoundingCylinder(Double_t* param)">GetBoundingCylinder</a>(<a href="../ListOfTypes.html#Double_t">Double_t</a> *param) <span class="keyword">const</span>
{
<span class="comment">//--- Fill vector param[4] with the bounding cylinder parameters. The order</span>
<span class="comment">// is the following : Rmin, Rmax, Phi1, Phi2</span>
   param[0] = fRmin;
   param[0] *= param[0];
   param[1] = fRmax;
   param[1] *= param[1];
   param[2] = fPhi1;
   param[3] = fPhi2;
}

<span class="comment">//_____________________________________________________________________________</span>
TGeoShape *<a href="../TUCNGeoTubeSeg.html">TUCNGeoTubeSeg</a>::<a href="../TUCNGeoTubeSeg.html#TUCNGeoTubeSeg:GetMakeRuntimeShape" title="TGeoShape* TUCNGeoTubeSeg::GetMakeRuntimeShape(TGeoShape* mother,TGeoMatrix* mat)">GetMakeRuntimeShape</a>(TGeoShape *mother, TGeoMatrix * <span class="comment">/*mat*/</span>) <span class="keyword">const</span>
{
<span class="comment">// in case shape has some negative parameters, these has to be computed</span>
<span class="comment">// in order to fit the mother</span>
   <span class="keyword">if</span> (!<a href="../#TGeoShape:TestShapeBit" title="Bool_t TGeoShape::TestShapeBit(UInt_t f)">TestShapeBit</a>(kGeoRunTimeShape)) <span class="keyword">return</span> 0;
   <span class="keyword">if</span> (!mother-&gt;<a href="../#TGeoShape:TestShapeBit" title="Bool_t TGeoShape::TestShapeBit(UInt_t f)">TestShapeBit</a>(kGeoTube)) {
      <a href="../#TObject:Error" title="void TObject::Error(const char* method,const char* msgfmt)">Error</a>(<span class="string">"GetMakeRuntimeShape"</span>, <span class="string">"Invalid mother for shape %s"</span>, <a href="../#TGeoShape:GetName" title="const char* TGeoShape::GetName()">GetName</a>());
      <span class="keyword">return</span> 0;
   }
   <a href="../ListOfTypes.html#Double_t">Double_t</a> rmin, rmax, dz;
   rmin = fRmin;
   rmax = fRmax;
   dz = fDz;
   <span class="keyword">if</span> (fDz&lt;0) dz=((<a href="../TUCNGeoTube.html">TUCNGeoTube</a>*)mother)-&gt;<a href="../TUCNGeoTube.html#TUCNGeoTube:GetDz" title="Double_t TUCNGeoTube::GetDz()">GetDz</a>();
   <span class="keyword">if</span> (fRmin&lt;0)
      rmin = ((<a href="../TUCNGeoTube.html">TUCNGeoTube</a>*)mother)-&gt;<a href="../TUCNGeoTube.html#TUCNGeoTube:GetRmin" title="Double_t TUCNGeoTube::GetRmin()">GetRmin</a>();
   <span class="keyword">if</span> ((fRmax&lt;0) || (fRmax&lt;=fRmin))
      rmax = ((<a href="../TUCNGeoTube.html">TUCNGeoTube</a>*)mother)-&gt;<a href="../TUCNGeoTube.html#TUCNGeoTube:GetRmax" title="Double_t TUCNGeoTube::GetRmax()">GetRmax</a>();

   <span class="keyword">return</span> (<span class="keyword">new</span> <a href="../TUCNGeoTubeSeg.html">TUCNGeoTubeSeg</a>(<a href="../#TGeoShape:GetName" title="const char* TGeoShape::GetName()">GetName</a>(),rmin, rmax, dz, fPhi1, fPhi2));
}

<span class="comment">//_____________________________________________________________________________</span>
<span class="keyword">void</span> <a href="../TUCNGeoTubeSeg.html">TUCNGeoTubeSeg</a>::<a href="../TUCNGeoTubeSeg.html#TUCNGeoTubeSeg:InspectShape" title="void TUCNGeoTubeSeg::InspectShape()">InspectShape</a>() <span class="keyword">const</span>
{
<span class="comment">// print shape parameters</span>
   printf(<span class="string">"*** Shape %s: TUCNGeoTubeSeg ***\n"</span>, <a href="../#TGeoShape:GetName" title="const char* TGeoShape::GetName()">GetName</a>());
   printf(<span class="string">"    Rmin = %11.5f\n"</span>, fRmin);
   printf(<span class="string">"    Rmax = %11.5f\n"</span>, fRmax);
   printf(<span class="string">"    dz   = %11.5f\n"</span>, fDz);
   printf(<span class="string">"    phi1 = %11.5f\n"</span>, fPhi1);
   printf(<span class="string">"    phi2 = %11.5f\n"</span>, fPhi2);
   printf(<span class="string">" Bounding box:\n"</span>);
   <a href="../TUCNGeoBBox.html">TUCNGeoBBox</a>::<a href="../#TGeoBBox:InspectShape" title="void TGeoBBox::InspectShape()">InspectShape</a>();
}

<span class="comment">//_____________________________________________________________________________</span>
TBuffer3D *<a href="../TUCNGeoTubeSeg.html">TUCNGeoTubeSeg</a>::<a href="../TUCNGeoTubeSeg.html#TUCNGeoTubeSeg:MakeBuffer3D" title="TBuffer3D* TUCNGeoTubeSeg::MakeBuffer3D()">MakeBuffer3D</a>() <span class="keyword">const</span>
{
   <span class="comment">// Creates a TBuffer3D describing *this* shape.</span>
   <span class="comment">// Coordinates are in local reference frame.</span>

   <a href="../ListOfTypes.html#Int_t">Int_t</a> n = gGeoManager-&gt;GetNsegments()+1;
   <a href="../ListOfTypes.html#Int_t">Int_t</a> nbPnts = 4*n;
   <a href="../ListOfTypes.html#Int_t">Int_t</a> nbSegs = 2*nbPnts;
   <a href="../ListOfTypes.html#Int_t">Int_t</a> nbPols = nbPnts-2;

   TBuffer3D* buff = <span class="keyword">new</span> TBuffer3D(TBuffer3DTypes::kGeneric,
                                   nbPnts, 3*nbPnts, nbSegs, 3*nbSegs, nbPols, 6*nbPols);
   <span class="keyword">if</span> (buff)
   {
      <a href="../TUCNGeoCtub.html#TUCNGeoCtub:SetPoints" title="void TUCNGeoCtub::SetPoints(Double_t* points) or overloads">SetPoints</a>(buff-&gt;fPnts);
      <a href="../TUCNGeoTubeSeg.html#TUCNGeoTubeSeg:SetSegsAndPols" title="void TUCNGeoTubeSeg::SetSegsAndPols(TBuffer3D&amp; buff)">SetSegsAndPols</a>(*buff);
   }

   <span class="keyword">return</span> buff;
}

<span class="comment">//_____________________________________________________________________________</span>
<span class="keyword">void</span> <a href="../TUCNGeoTubeSeg.html">TUCNGeoTubeSeg</a>::<a href="../TUCNGeoTubeSeg.html#TUCNGeoTubeSeg:SetSegsAndPols" title="void TUCNGeoTubeSeg::SetSegsAndPols(TBuffer3D&amp; buff)">SetSegsAndPols</a>(TBuffer3D &amp;buff) <span class="keyword">const</span>
{
<span class="comment">// Fill TBuffer3D structure for segments and polygons.</span>
   <a href="../ListOfTypes.html#Int_t">Int_t</a> i, j;
   <a href="../ListOfTypes.html#Int_t">Int_t</a> n = gGeoManager-&gt;GetNsegments()+1;
   <a href="../ListOfTypes.html#Int_t">Int_t</a> c = <a href="../#TGeoShape:GetBasicColor" title="Int_t TGeoShape::GetBasicColor()">GetBasicColor</a>();

   memset(buff.fSegs, 0, buff.NbSegs()*3*<span class="keyword">sizeof</span>(<a href="../ListOfTypes.html#Int_t">Int_t</a>));
   <span class="keyword">for</span> (i = 0; i &lt; 4; i++) {
      <span class="keyword">for</span> (j = 1; j &lt; n; j++) {
         buff.fSegs[(i*n+j-1)*3  ] = c;
         buff.fSegs[(i*n+j-1)*3+1] = i*n+j-1;
         buff.fSegs[(i*n+j-1)*3+2] = i*n+j;
      }
   }
   <span class="keyword">for</span> (i = 4; i &lt; 6; i++) {
      <span class="keyword">for</span> (j = 0; j &lt; n; j++) {
         buff.fSegs[(i*n+j)*3  ] = c+1;
         buff.fSegs[(i*n+j)*3+1] = (i-4)*n+j;
         buff.fSegs[(i*n+j)*3+2] = (i-2)*n+j;
      }
   }
   <span class="keyword">for</span> (i = 6; i &lt; 8; i++) {
      <span class="keyword">for</span> (j = 0; j &lt; n; j++) {
         buff.fSegs[(i*n+j)*3  ] = c;
         buff.fSegs[(i*n+j)*3+1] = 2*(i-6)*n+j;
         buff.fSegs[(i*n+j)*3+2] = (2*(i-6)+1)*n+j;
      }
   }

   <a href="../ListOfTypes.html#Int_t">Int_t</a> indx = 0;
   memset(buff.fPols, 0, buff.NbPols()*6*<span class="keyword">sizeof</span>(<a href="../ListOfTypes.html#Int_t">Int_t</a>));
   i = 0;
   <span class="keyword">for</span> (j = 0; j &lt; n-1; j++) {
      buff.fPols[indx++] = c;
      buff.fPols[indx++] = 4;
      buff.fPols[indx++] = (4+i)*n+j+1;
      buff.fPols[indx++] = (2+i)*n+j;
      buff.fPols[indx++] = (4+i)*n+j;
      buff.fPols[indx++] = i*n+j;
   }
   i = 1;
   <span class="keyword">for</span> (j = 0; j &lt; n-1; j++) {
      buff.fPols[indx++] = c;
      buff.fPols[indx++] = 4;
      buff.fPols[indx++] = i*n+j;
      buff.fPols[indx++] = (4+i)*n+j;
      buff.fPols[indx++] = (2+i)*n+j;
      buff.fPols[indx++] = (4+i)*n+j+1;
   }
   i = 2;
   <span class="keyword">for</span> (j = 0; j &lt; n-1; j++) {
      buff.fPols[indx++] = c+i;
      buff.fPols[indx++] = 4;
      buff.fPols[indx++] = (i-2)*2*n+j;
      buff.fPols[indx++] = (4+i)*n+j;
      buff.fPols[indx++] = ((i-2)*2+1)*n+j;
      buff.fPols[indx++] = (4+i)*n+j+1;
   }
   i = 3;
   <span class="keyword">for</span> (j = 0; j &lt; n-1; j++) {
      buff.fPols[indx++] = c+i;
      buff.fPols[indx++] = 4;
      buff.fPols[indx++] = (4+i)*n+j+1;
      buff.fPols[indx++] = ((i-2)*2+1)*n+j;
      buff.fPols[indx++] = (4+i)*n+j;
      buff.fPols[indx++] = (i-2)*2*n+j;
   }
   buff.fPols[indx++] = c+2;
   buff.fPols[indx++] = 4;
   buff.fPols[indx++] = 6*n;
   buff.fPols[indx++] = 4*n;
   buff.fPols[indx++] = 7*n;
   buff.fPols[indx++] = 5*n;
   buff.fPols[indx++] = c+2;
   buff.fPols[indx++] = 4;
   buff.fPols[indx++] = 6*n-1;
   buff.fPols[indx++] = 8*n-1;
   buff.fPols[indx++] = 5*n-1;
   buff.fPols[indx++] = 7*n-1;
}

<span class="comment">//_____________________________________________________________________________</span>
<a href="../ListOfTypes.html#Double_t">Double_t</a> <a href="../TUCNGeoTubeSeg.html">TUCNGeoTubeSeg</a>::<a href="../TUCNGeoTubeSeg.html#TUCNGeoTubeSeg:Safety" title="Double_t TUCNGeoTubeSeg::Safety(Double_t* point,Bool_t in=kTRUE)">Safety</a>(<a href="../ListOfTypes.html#Double_t">Double_t</a> *point, <a href="../ListOfTypes.html#Bool_t">Bool_t</a> in) <span class="keyword">const</span>
{
<span class="comment">// computes the closest distance from given point to this shape, according</span>
<span class="comment">// to option. The matching point on the shape is stored in spoint.</span>
   <a href="../ListOfTypes.html#Double_t">Double_t</a> saf[3];
   <a href="../ListOfTypes.html#Double_t">Double_t</a> rsq = point[0]*point[0]+point[1]*point[1];
   <a href="../ListOfTypes.html#Double_t">Double_t</a> r = TMath::Sqrt(rsq);

   <a href="../ListOfTypes.html#Double_t">Double_t</a> safe = TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
   <span class="keyword">if</span> (in) {
      saf[0] = fDz-TMath::Abs(point[2]);
      saf[1] = r-fRmin;
      saf[2] = fRmax-r;
      safe   = saf[TMath::LocMin(3,saf)];
   } <span class="keyword">else</span> {
   <span class="comment">// at least one positive</span>
      saf[0] = TMath::Abs(point[2])-fDz;
      saf[1] = fRmin-r;
      saf[2] = r-fRmax;
      safe   = saf[TMath::LocMax(3,saf)];
   }
   <span class="keyword">if</span> ((fPhi2-fPhi1)&gt;=360.) <span class="keyword">return</span> safe;
   <a href="../ListOfTypes.html#Double_t">Double_t</a> safphi = TGeoShape::<a href="../#TGeoShape:SafetyPhi" title="Double_t TGeoShape::SafetyPhi(Double_t* point,Bool_t in,Double_t phi1,Double_t phi2)">SafetyPhi</a>(point,in,fPhi1,fPhi2);

   <span class="keyword">if</span> (in) <span class="keyword">return</span> TMath::Min(safe, safphi);
   <span class="keyword">return</span> TMath::Max(safe, safphi);
}

<span class="comment">//_____________________________________________________________________________</span>
<a href="../ListOfTypes.html#Double_t">Double_t</a> <a href="../TUCNGeoTubeSeg.html">TUCNGeoTubeSeg</a>::<a href="../TUCNGeoTubeSeg.html#TUCNGeoTubeSeg:SafetyS" title="Double_t TUCNGeoTubeSeg::SafetyS(Double_t* point,Bool_t in,Double_t rmin,Double_t rmax,Double_t dz,Double_t phi1,Double_t phi2,Int_t skipz=0)">SafetyS</a>(<a href="../ListOfTypes.html#Double_t">Double_t</a> *point, <a href="../ListOfTypes.html#Bool_t">Bool_t</a> in, <a href="../ListOfTypes.html#Double_t">Double_t</a> rmin, <a href="../ListOfTypes.html#Double_t">Double_t</a> rmax, <a href="../ListOfTypes.html#Double_t">Double_t</a> dz,
                              <a href="../ListOfTypes.html#Double_t">Double_t</a> phi1, <a href="../ListOfTypes.html#Double_t">Double_t</a> phi2, <a href="../ListOfTypes.html#Int_t">Int_t</a> skipz)
{
<span class="comment">// Static method to compute the closest distance from given point to this shape.</span>
   <a href="../ListOfTypes.html#Double_t">Double_t</a> saf[3];
   <a href="../ListOfTypes.html#Double_t">Double_t</a> rsq = point[0]*point[0]+point[1]*point[1];
   <a href="../ListOfTypes.html#Double_t">Double_t</a> r = TMath::Sqrt(rsq);

   <span class="keyword">switch</span> (skipz) {
      <span class="keyword">case</span> 1: <span class="comment">// skip lower Z plane</span>
         saf[0] = dz - point[2];
         <span class="keyword">break</span>;
      <span class="keyword">case</span> 2: <span class="comment">// skip upper Z plane</span>
         saf[0] = dz + point[2];
         <span class="keyword">break</span>;
      <span class="keyword">case</span> 3: <span class="comment">// skip both</span>
         saf[0] = TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
         <span class="keyword">break</span>;
      <span class="keyword">default</span>:
         saf[0] = dz-TMath::Abs(point[2]);
   }
   saf[1] = r-rmin;
   saf[2] = rmax-r;
   <a href="../ListOfTypes.html#Double_t">Double_t</a> safphi = TGeoShape::<a href="../#TGeoShape:SafetyPhi" title="Double_t TGeoShape::SafetyPhi(Double_t* point,Bool_t in,Double_t phi1,Double_t phi2)">SafetyPhi</a>(point,in,phi1,phi2);
   <a href="../ListOfTypes.html#Double_t">Double_t</a> safe = TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();

   <span class="keyword">if</span> (in)  {
      safe = saf[TMath::LocMin(3,saf)];
      <span class="keyword">return</span> TMath::Min(safe, safphi);
   }

   <span class="keyword">for</span> (<a href="../ListOfTypes.html#Int_t">Int_t</a> i=0; i&lt;3; i++) saf[i]=-saf[i];
   safe = saf[TMath::LocMax(3,saf)];
   <span class="keyword">return</span> TMath::Max(safe, safphi);
}

<span class="comment">//_____________________________________________________________________________</span>
<span class="keyword">void</span> <a href="../TUCNGeoTubeSeg.html">TUCNGeoTubeSeg</a>::<a href="../TUCNGeoTubeSeg.html#TUCNGeoTubeSeg:SavePrimitive" title="void TUCNGeoTubeSeg::SavePrimitive(ostream&amp; out,Option_t* option=&quot;&quot;)">SavePrimitive</a>(<a href="../ListOfTypes.html#ostream">ostream</a> &amp;out, <a href="../ListOfTypes.html#Option_t">Option_t</a> * <span class="comment">/*option*/</span> <span class="comment">/*= <span class="string">""</span>*/</span>)
{
<span class="comment">// Save a primitive as a C++ statement(s) on output stream <span class="string">"out"</span>.</span>
   <span class="keyword">if</span> (<a href="../#TObject:TObject" title="TObject TObject::TObject() or overloads">TObject</a>::<a href="../#TObject:TestBit" title="Bool_t TObject::TestBit(UInt_t f)">TestBit</a>(kGeoSavePrimitive)) <span class="keyword">return</span>;
   out &lt;&lt; <span class="string">"   // Shape: "</span> &lt;&lt; <a href="../#TGeoShape:GetName" title="const char* TGeoShape::GetName()">GetName</a>() &lt;&lt; <span class="string">" type: "</span> &lt;&lt; <a href="../#TObject:ClassName" title="const char* TObject::ClassName()">ClassName</a>() &lt;&lt; endl;
   out &lt;&lt; <span class="string">"   rmin = "</span> &lt;&lt; fRmin &lt;&lt; <span class="string">";"</span> &lt;&lt; endl;
   out &lt;&lt; <span class="string">"   rmax = "</span> &lt;&lt; fRmax &lt;&lt; <span class="string">";"</span> &lt;&lt; endl;
   out &lt;&lt; <span class="string">"   dz   = "</span> &lt;&lt; fDz &lt;&lt; <span class="string">";"</span> &lt;&lt; endl;
   out &lt;&lt; <span class="string">"   phi1 = "</span> &lt;&lt; fPhi1 &lt;&lt; <span class="string">";"</span> &lt;&lt; endl;
   out &lt;&lt; <span class="string">"   phi2 = "</span> &lt;&lt; fPhi2 &lt;&lt; <span class="string">";"</span> &lt;&lt; endl;
   out &lt;&lt; <span class="string">"   TGeoShape *"</span> &lt;&lt; <a href="../#TGeoShape:GetPointerName" title="char* TGeoShape::GetPointerName()">GetPointerName</a>() &lt;&lt; <span class="string">" = new TUCNGeoTubeSeg(\""</span> &lt;&lt; <a href="../#TGeoShape:GetName" title="const char* TGeoShape::GetName()">GetName</a>() &lt;&lt; <span class="string">"\",rmin,rmax,dz,phi1,phi2);"</span> &lt;&lt; endl;
   <a href="../#TObject:TObject" title="TObject TObject::TObject() or overloads">TObject</a>::<a href="../#TObject:SetBit" title="void TObject::SetBit(UInt_t f,Bool_t set) or overloads">SetBit</a>(TGeoShape::kGeoSavePrimitive);
}

<span class="comment">//_____________________________________________________________________________</span>
<span class="keyword">void</span> <a href="../TUCNGeoTubeSeg.html">TUCNGeoTubeSeg</a>::<a href="../TUCNGeoTubeSeg.html#TUCNGeoTubeSeg:SetTubsDimensions" title="void TUCNGeoTubeSeg::SetTubsDimensions(Double_t rmin,Double_t rmax,Double_t dz,Double_t phi1,Double_t phi2)">SetTubsDimensions</a>(<a href="../ListOfTypes.html#Double_t">Double_t</a> rmin, <a href="../ListOfTypes.html#Double_t">Double_t</a> rmax, <a href="../ListOfTypes.html#Double_t">Double_t</a> dz,
                          <a href="../ListOfTypes.html#Double_t">Double_t</a> phi1, <a href="../ListOfTypes.html#Double_t">Double_t</a> phi2)
{
<span class="comment">// Set dimensions of the tube segment.</span>
   fRmin = rmin;
   fRmax = rmax;
   fDz   = dz;
   fPhi1 = phi1;
   <span class="keyword">if</span> (fPhi1 &lt; 0) fPhi1+=360.;
   fPhi2 = phi2;
   <span class="keyword">while</span> (fPhi2&lt;=fPhi1) fPhi2+=360.;
   <span class="keyword">if</span> (fPhi1==fPhi2) <a href="../#TObject:Error" title="void TObject::Error(const char* method,const char* msgfmt)">Error</a>(<span class="string">"SetTubsDimensions"</span>, <span class="string">"In shape %s invalid phi1=%g, phi2=%g\n"</span>, <a href="../#TGeoShape:GetName" title="const char* TGeoShape::GetName()">GetName</a>(), fPhi1, fPhi2);
}

<span class="comment">//_____________________________________________________________________________</span>
<span class="keyword">void</span> <a href="../TUCNGeoTubeSeg.html">TUCNGeoTubeSeg</a>::<a href="../TUCNGeoTubeSeg.html#TUCNGeoTubeSeg:SetDimensions" title="void TUCNGeoTubeSeg::SetDimensions(Double_t* param)">SetDimensions</a>(<a href="../ListOfTypes.html#Double_t">Double_t</a> *param)
{
<span class="comment">// Set dimensions of the tube segment starting from a list.</span>
   <a href="../ListOfTypes.html#Double_t">Double_t</a> rmin = param[0];
   <a href="../ListOfTypes.html#Double_t">Double_t</a> rmax = param[1];
   <a href="../ListOfTypes.html#Double_t">Double_t</a> dz   = param[2];
   <a href="../ListOfTypes.html#Double_t">Double_t</a> phi1 = param[3];
   <a href="../ListOfTypes.html#Double_t">Double_t</a> phi2 = param[4];
   <a href="../TUCNGeoTubeSeg.html#TUCNGeoTubeSeg:SetTubsDimensions" title="void TUCNGeoTubeSeg::SetTubsDimensions(Double_t rmin,Double_t rmax,Double_t dz,Double_t phi1,Double_t phi2)">SetTubsDimensions</a>(rmin, rmax, dz, phi1, phi2);
}

<span class="comment">//_____________________________________________________________________________</span>
<a href="../ListOfTypes.html#Bool_t">Bool_t</a> <a href="../TUCNGeoTubeSeg.html">TUCNGeoTubeSeg</a>::<a href="../TUCNGeoTubeSeg.html#TUCNGeoTubeSeg:GetPointsOnSegments" title="Bool_t TUCNGeoTubeSeg::GetPointsOnSegments(Int_t npoints,Double_t* array)">GetPointsOnSegments</a>(<a href="../ListOfTypes.html#Int_t">Int_t</a> npoints, <a href="../ListOfTypes.html#Double_t">Double_t</a> *array) <span class="keyword">const</span>
{
<span class="comment">// Fills array with n random points located on the line segments of the shape mesh.</span>
<span class="comment">// The output array must be provided with a length of minimum 3*npoints. Returns</span>
<span class="comment">// <a href="../ListOfTypes.html#bool">true</a> if operation is implemented.</span>
   <span class="keyword">if</span> (npoints &gt; (npoints/2)*2) {
      <a href="../#TObject:Error" title="void TObject::Error(const char* method,const char* msgfmt)">Error</a>(<span class="string">"GetPointsOnSegments"</span>,<span class="string">"Npoints must be even number"</span>);
      <span class="keyword">return</span> <a href="../ListOfTypes.html#Bool_t">kFALSE</a>;
   }   
   <a href="../ListOfTypes.html#Int_t">Int_t</a> nc = (<a href="../ListOfTypes.html#Int_t">Int_t</a>)TMath::Sqrt(0.5*npoints);
   <a href="../ListOfTypes.html#Double_t">Double_t</a> dphi = (fPhi2-fPhi1)*TMath::DegToRad()/(nc-1);
   <a href="../ListOfTypes.html#Double_t">Double_t</a> phi = 0;
   <a href="../ListOfTypes.html#Double_t">Double_t</a> phi1 = fPhi1 * TMath::DegToRad();
   <a href="../ListOfTypes.html#Int_t">Int_t</a> ntop = npoints/2 - nc*(nc-1);
   <a href="../ListOfTypes.html#Double_t">Double_t</a> dz = 2*fDz/(nc-1);
   <a href="../ListOfTypes.html#Double_t">Double_t</a> z = 0;
   <a href="../ListOfTypes.html#Int_t">Int_t</a> icrt = 0;
   <a href="../ListOfTypes.html#Int_t">Int_t</a> nphi = nc;
   <span class="comment">// loop z sections</span>
   <span class="keyword">for</span> (<a href="../ListOfTypes.html#Int_t">Int_t</a> i=0; i&lt;nc; i++) {
      <span class="keyword">if</span> (i == (nc-1)) {
         nphi = ntop;
         dphi = (fPhi2-fPhi1)*TMath::DegToRad()/(nphi-1);
      }   
      z = -fDz + i*dz;
      <span class="comment">// loop points on circle sections</span>
      <span class="keyword">for</span> (<a href="../ListOfTypes.html#Int_t">Int_t</a> j=0; j&lt;nphi; j++) {
         phi = phi1 + j*dphi;
         array[icrt++] = fRmin * TMath::Cos(phi);
         array[icrt++] = fRmin * TMath::Sin(phi);
         array[icrt++] = z;
         array[icrt++] = fRmax * TMath::Cos(phi);
         array[icrt++] = fRmax * TMath::Sin(phi);
         array[icrt++] = z;
      }
   }
   <span class="keyword">return</span> <a href="../ListOfTypes.html#Bool_t">kTRUE</a>;
}
   
<span class="comment">//_____________________________________________________________________________</span>
<span class="keyword">void</span> <a href="../TUCNGeoTubeSeg.html">TUCNGeoTubeSeg</a>::<a href="../TUCNGeoTubeSeg.html#TUCNGeoTubeSeg:SetPoints" title="void TUCNGeoTubeSeg::SetPoints(Double_t* points) or overloads">SetPoints</a>(<a href="../ListOfTypes.html#Double_t">Double_t</a> *points) <span class="keyword">const</span>
{
<span class="comment">// Create tube segment mesh points.</span>
   <a href="../ListOfTypes.html#Double_t">Double_t</a> dz;
   <a href="../ListOfTypes.html#Int_t">Int_t</a> j, n;
   <a href="../ListOfTypes.html#Double_t">Double_t</a> phi, phi1, phi2, dphi;
   phi1 = fPhi1;
   phi2 = fPhi2;
   <span class="keyword">if</span> (phi2&lt;phi1) phi2+=360.;
   n = gGeoManager-&gt;GetNsegments()+1;

   dphi = (phi2-phi1)/(n-1);
   dz   = fDz;

   <span class="keyword">if</span> (points) {
      <a href="../ListOfTypes.html#Int_t">Int_t</a> indx = 0;

      <span class="keyword">for</span> (j = 0; j &lt; n; j++) {
         phi = (phi1+j*dphi)*TMath::DegToRad();
         points[indx+6*n] = points[indx] = fRmin * TMath::Cos(phi);
         indx++;
         points[indx+6*n] = points[indx] = fRmin * TMath::Sin(phi);
         indx++;
         points[indx+6*n] = dz;
         points[indx]     =-dz;
         indx++;
      }
      <span class="keyword">for</span> (j = 0; j &lt; n; j++) {
         phi = (phi1+j*dphi)*TMath::DegToRad();
         points[indx+6*n] = points[indx] = fRmax * TMath::Cos(phi);
         indx++;
         points[indx+6*n] = points[indx] = fRmax * TMath::Sin(phi);
         indx++;
         points[indx+6*n]= dz;
         points[indx]    =-dz;
         indx++;
      }
   }
}

<span class="comment">//_____________________________________________________________________________</span>
<span class="keyword">void</span> <a href="../TUCNGeoTubeSeg.html">TUCNGeoTubeSeg</a>::<a href="../TUCNGeoTubeSeg.html#TUCNGeoTubeSeg:SetPoints" title="void TUCNGeoTubeSeg::SetPoints(Double_t* points) or overloads">SetPoints</a>(<a href="../ListOfTypes.html#Float_t">Float_t</a> *points) <span class="keyword">const</span>
{
<span class="comment">// Create tube segment mesh points.</span>
   <a href="../ListOfTypes.html#Double_t">Double_t</a> dz;
   <a href="../ListOfTypes.html#Int_t">Int_t</a> j, n;
   <a href="../ListOfTypes.html#Double_t">Double_t</a> phi, phi1, phi2, dphi;
   phi1 = fPhi1;
   phi2 = fPhi2;
   <span class="keyword">if</span> (phi2&lt;phi1) phi2+=360.;
   n = gGeoManager-&gt;GetNsegments()+1;

   dphi = (phi2-phi1)/(n-1);
   dz   = fDz;

   <span class="keyword">if</span> (points) {
      <a href="../ListOfTypes.html#Int_t">Int_t</a> indx = 0;

      <span class="keyword">for</span> (j = 0; j &lt; n; j++) {
         phi = (phi1+j*dphi)*TMath::DegToRad();
         points[indx+6*n] = points[indx] = fRmin * TMath::Cos(phi);
         indx++;
         points[indx+6*n] = points[indx] = fRmin * TMath::Sin(phi);
         indx++;
         points[indx+6*n] = dz;
         points[indx]     =-dz;
         indx++;
      }
      <span class="keyword">for</span> (j = 0; j &lt; n; j++) {
         phi = (phi1+j*dphi)*TMath::DegToRad();
         points[indx+6*n] = points[indx] = fRmax * TMath::Cos(phi);
         indx++;
         points[indx+6*n] = points[indx] = fRmax * TMath::Sin(phi);
         indx++;
         points[indx+6*n]= dz;
         points[indx]    =-dz;
         indx++;
      }
   }
}

<span class="comment">//_____________________________________________________________________________</span>
<span class="keyword">void</span> <a href="../TUCNGeoTubeSeg.html">TUCNGeoTubeSeg</a>::<a href="../TUCNGeoTubeSeg.html#TUCNGeoTubeSeg:GetMeshNumbers" title="void TUCNGeoTubeSeg::GetMeshNumbers(Int_t&amp; nvert,Int_t&amp; nsegs,Int_t&amp; npols)">GetMeshNumbers</a>(<a href="../ListOfTypes.html#Int_t">Int_t</a> &amp;nvert, <a href="../ListOfTypes.html#Int_t">Int_t</a> &amp;nsegs, <a href="../ListOfTypes.html#Int_t">Int_t</a> &amp;npols) <span class="keyword">const</span>
{
<span class="comment">// Returns numbers of vertices, segments and polygons composing the shape mesh.</span>
   <a href="../ListOfTypes.html#Int_t">Int_t</a> n = gGeoManager-&gt;GetNsegments()+1;
   nvert = n*4;
   nsegs = n*8;
   npols = n*4 - 2;
}

<span class="comment">//_____________________________________________________________________________</span>
<a href="../ListOfTypes.html#Int_t">Int_t</a> <a href="../TUCNGeoTubeSeg.html">TUCNGeoTubeSeg</a>::<a href="../TUCNGeoTubeSeg.html#TUCNGeoTubeSeg:GetNmeshVertices" title="Int_t TUCNGeoTubeSeg::GetNmeshVertices()">GetNmeshVertices</a>() <span class="keyword">const</span>
{
<span class="comment">// Return number of vertices of the mesh representation</span>
   <a href="../ListOfTypes.html#Int_t">Int_t</a> n = gGeoManager-&gt;GetNsegments()+1;
   <a href="../ListOfTypes.html#Int_t">Int_t</a> numPoints = n*4;
   <span class="keyword">return</span> numPoints;
}

<span class="comment">//_____________________________________________________________________________</span>
<span class="keyword">void</span> <a href="../TUCNGeoTubeSeg.html">TUCNGeoTubeSeg</a>::<a href="../TUCNGeoTubeSeg.html#TUCNGeoTubeSeg:Sizeof3D" title="void TUCNGeoTubeSeg::Sizeof3D()">Sizeof3D</a>() <span class="keyword">const</span>
{
<span class="comment">///// fill size of this 3-D object</span>
<span class="comment">///    TVirtualGeoPainter *painter = gGeoManager-&gt;GetGeomPainter();</span>
<span class="comment">///    if (!painter) return;</span>
<span class="comment">///</span>
<span class="comment">///    <a href="../ListOfTypes.html#Int_t">Int_t</a> n = gGeoManager-&gt;GetNsegments()+1;</span>
<span class="comment">///    <a href="../ListOfTypes.html#Int_t">Int_t</a> numPoints = n*4;</span>
<span class="comment">///    <a href="../ListOfTypes.html#Int_t">Int_t</a> numSegs   = n*8;</span>
<span class="comment">///    <a href="../ListOfTypes.html#Int_t">Int_t</a> numPolys  = n*4-2;</span>
<span class="comment">///</span>
<span class="comment">///    painter-&gt;AddSize3D(numPoints, numSegs, numPolys);</span>
}

<span class="comment">//_____________________________________________________________________________</span>
<span class="keyword">const</span> TBuffer3D &amp; <a href="../TUCNGeoTubeSeg.html">TUCNGeoTubeSeg</a>::<a href="../TUCNGeoTubeSeg.html#TUCNGeoTubeSeg:GetBuffer3D" title="const TBuffer3D&amp; TUCNGeoTubeSeg::GetBuffer3D(Int_t reqSections,Bool_t localFrame)">GetBuffer3D</a>(<a href="../ListOfTypes.html#Int_t">Int_t</a> reqSections, <a href="../ListOfTypes.html#Bool_t">Bool_t</a> localFrame) <span class="keyword">const</span>
{
<span class="comment">// Fills a static 3D buffer and returns a reference.</span>
   <span class="keyword">static</span> TBuffer3DTubeSeg buffer;
   <a href="../TUCNGeoBBox.html">TUCNGeoBBox</a>::<a href="../#TGeoBBox:FillBuffer3D" title="void TGeoBBox::FillBuffer3D(TBuffer3D&amp; buffer,Int_t reqSections,Bool_t localFrame)">FillBuffer3D</a>(buffer, reqSections, localFrame);

   <span class="keyword">if</span> (reqSections &amp; TBuffer3D::kShapeSpecific) {
      <span class="comment">// These from TBuffer3DTube / <a href="../TUCNGeoTube.html">TUCNGeoTube</a></span>
      buffer.fRadiusInner  = fRmin;
      buffer.fRadiusOuter  = fRmax;
      buffer.fHalfLength   = fDz;
      buffer.fPhiMin       = fPhi1;
      buffer.fPhiMax       = fPhi2;
      buffer.SetSectionsValid(TBuffer3D::kShapeSpecific);
   }
   <span class="keyword">if</span> (reqSections &amp; TBuffer3D::kRawSizes) {
      <a href="../ListOfTypes.html#Int_t">Int_t</a> n = gGeoManager-&gt;GetNsegments()+1;
      <a href="../ListOfTypes.html#Int_t">Int_t</a> nbPnts = 4*n;
      <a href="../ListOfTypes.html#Int_t">Int_t</a> nbSegs = 2*nbPnts;
      <a href="../ListOfTypes.html#Int_t">Int_t</a> nbPols = nbPnts-2;
      <span class="keyword">if</span> (buffer.SetRawSizes(nbPnts, 3*nbPnts, nbSegs, 3*nbSegs, nbPols, 6*nbPols)) {
         buffer.SetSectionsValid(TBuffer3D::kRawSizes);
      }
   }
   <span class="keyword">if</span> ((reqSections &amp; TBuffer3D::kRaw) &amp;&amp; buffer.SectionsValid(TBuffer3D::kRawSizes)) {
      <a href="../TUCNGeoCtub.html#TUCNGeoCtub:SetPoints" title="void TUCNGeoCtub::SetPoints(Double_t* points) or overloads">SetPoints</a>(buffer.fPnts);
      <span class="keyword">if</span> (!buffer.fLocalFrame) {
         <a href="../#TGeoShape:TransformPoints" title="void TGeoShape::TransformPoints(Double_t* points,UInt_t NbPoints)">TransformPoints</a>(buffer.fPnts, buffer.NbPnts());
      }
      <a href="../TUCNGeoTubeSeg.html#TUCNGeoTubeSeg:SetSegsAndPols" title="void TUCNGeoTubeSeg::SetSegsAndPols(TBuffer3D&amp; buff)">SetSegsAndPols</a>(buffer);
      buffer.SetSectionsValid(TBuffer3D::kRaw);
   }

   <span class="keyword">return</span> buffer;
}

ClassImp(<a href="../TUCNGeoCtub.html">TUCNGeoCtub</a>)

<a name="ejGXnD"></a><a href="../TUCNGeoCtub.html">TUCNGeoCtub</a>::<a href="../TUCNGeoCtub.html#TUCNGeoCtub:TUCNGeoCtub" title="TUCNGeoCtub TUCNGeoCtub::TUCNGeoCtub() or overloads">TUCNGeoCtub</a>()
{
<span class="comment">// default ctor</span>
   <a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[0] = <a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[1] = <a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[0] = <a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[1] = 0.;
   <a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[2] = -1;
   <a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[2] = 1;
}

<span class="comment">//_____________________________________________________________________________</span>
<a name="Kzb7pB"></a><a href="../TUCNGeoCtub.html">TUCNGeoCtub</a>::<a href="../TUCNGeoCtub.html#TUCNGeoCtub:TUCNGeoCtub" title="TUCNGeoCtub TUCNGeoCtub::TUCNGeoCtub() or overloads">TUCNGeoCtub</a>(<a href="../ListOfTypes.html#Double_t">Double_t</a> rmin, <a href="../ListOfTypes.html#Double_t">Double_t</a> rmax, <a href="../ListOfTypes.html#Double_t">Double_t</a> dz, <a href="../ListOfTypes.html#Double_t">Double_t</a> phi1, <a href="../ListOfTypes.html#Double_t">Double_t</a> phi2,
                   <a href="../ListOfTypes.html#Double_t">Double_t</a> lx, <a href="../ListOfTypes.html#Double_t">Double_t</a> ly, <a href="../ListOfTypes.html#Double_t">Double_t</a> lz, <a href="../ListOfTypes.html#Double_t">Double_t</a> tx, <a href="../ListOfTypes.html#Double_t">Double_t</a> ty, <a href="../ListOfTypes.html#Double_t">Double_t</a> tz)
         :<a href="../TUCNGeoTubeSeg.html">TUCNGeoTubeSeg</a>(rmin, rmax, dz, phi1, phi2)
{
<span class="comment">// constructor</span>
   <a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[0] = lx;
   <a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[1] = ly;
   <a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[2] = lz;
   <a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[0] = tx;
   <a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[1] = ty;
   <a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[2] = tz;
   <a href="../#TGeoShape:SetShapeBit" title="void TGeoShape::SetShapeBit(UInt_t f,Bool_t set) or overloads">SetShapeBit</a>(kGeoCtub);
   <a href="../TUCNGeoCtub.html#TUCNGeoCtub:ComputeBBox" title="void TUCNGeoCtub::ComputeBBox()">ComputeBBox</a>();
}

<span class="comment">//_____________________________________________________________________________</span>
<a name="IAeS1E"></a><a href="../TUCNGeoCtub.html">TUCNGeoCtub</a>::<a href="../TUCNGeoCtub.html#TUCNGeoCtub:TUCNGeoCtub" title="TUCNGeoCtub TUCNGeoCtub::TUCNGeoCtub() or overloads">TUCNGeoCtub</a>(<span class="keyword">const</span> <span class="keyword">char</span> *name, <a href="../ListOfTypes.html#Double_t">Double_t</a> rmin, <a href="../ListOfTypes.html#Double_t">Double_t</a> rmax, <a href="../ListOfTypes.html#Double_t">Double_t</a> dz, <a href="../ListOfTypes.html#Double_t">Double_t</a> phi1, <a href="../ListOfTypes.html#Double_t">Double_t</a> phi2,
                   <a href="../ListOfTypes.html#Double_t">Double_t</a> lx, <a href="../ListOfTypes.html#Double_t">Double_t</a> ly, <a href="../ListOfTypes.html#Double_t">Double_t</a> lz, <a href="../ListOfTypes.html#Double_t">Double_t</a> tx, <a href="../ListOfTypes.html#Double_t">Double_t</a> ty, <a href="../ListOfTypes.html#Double_t">Double_t</a> tz)
         :<a href="../TUCNGeoTubeSeg.html">TUCNGeoTubeSeg</a>(name, rmin, rmax, dz, phi1, phi2)
{
<span class="comment">// constructor</span>
   <a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[0] = lx;
   <a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[1] = ly;
   <a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[2] = lz;
   <a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[0] = tx;
   <a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[1] = ty;
   <a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[2] = tz;
   <a href="../#TGeoShape:SetShapeBit" title="void TGeoShape::SetShapeBit(UInt_t f,Bool_t set) or overloads">SetShapeBit</a>(kGeoCtub);
   <a href="../TUCNGeoCtub.html#TUCNGeoCtub:ComputeBBox" title="void TUCNGeoCtub::ComputeBBox()">ComputeBBox</a>();
}

<span class="comment">//_____________________________________________________________________________</span>
<a name="JyWUGB"></a><a href="../TUCNGeoCtub.html">TUCNGeoCtub</a>::<a href="../TUCNGeoCtub.html#TUCNGeoCtub:TUCNGeoCtub" title="TUCNGeoCtub TUCNGeoCtub::TUCNGeoCtub() or overloads">TUCNGeoCtub</a>(<a href="../ListOfTypes.html#Double_t">Double_t</a> *params)
         :<a href="../TUCNGeoTubeSeg.html">TUCNGeoTubeSeg</a>(0,0,0,0,0)
{
<span class="comment">// ctor with parameters</span>
   <a href="../TUCNGeoCtub.html#TUCNGeoCtub:SetCtubDimensions" title="void TUCNGeoCtub::SetCtubDimensions(Double_t rmin,Double_t rmax,Double_t dz,Double_t phi1,Double_t phi2,Double_t lx,Double_t ly,Double_t lz,Double_t tx,Double_t ty,Double_t tz)">SetCtubDimensions</a>(params[0], params[1], params[2], params[3], params[4], params[5],
                     params[6], params[7], params[8], params[9], params[10]);
   <a href="../#TGeoShape:SetShapeBit" title="void TGeoShape::SetShapeBit(UInt_t f,Bool_t set) or overloads">SetShapeBit</a>(kGeoCtub);
}

<span class="comment">//_____________________________________________________________________________</span>
<a name="cby5WB"></a><a href="../TUCNGeoCtub.html">TUCNGeoCtub</a>::<a href="../TUCNGeoCtub.html#TUCNGeoCtub:_TUCNGeoCtub" title="void TUCNGeoCtub::~TUCNGeoCtub()">~TUCNGeoCtub</a>()
{
<span class="comment">// destructor</span>
}

<span class="comment">//_____________________________________________________________________________</span>
<a name="Ua4tqC"></a><a href="../ListOfTypes.html#Double_t">Double_t</a> <a href="../TUCNGeoCtub.html">TUCNGeoCtub</a>::<a href="../TUCNGeoCtub.html#TUCNGeoCtub:Capacity" title="Double_t TUCNGeoCtub::Capacity()">Capacity</a>() <span class="keyword">const</span>
{
<span class="comment">// Computes capacity of the shape in [length^3]</span>
   <a href="../ListOfTypes.html#Double_t">Double_t</a> capacity = <a href="../TUCNGeoTubeSeg.html">TUCNGeoTubeSeg</a>::<a href="../TUCNGeoTubeSeg.html#TUCNGeoTubeSeg:Capacity" title="Double_t TUCNGeoTubeSeg::Capacity() or overloads">Capacity</a>();
   <span class="keyword">return</span> capacity;
}   

<span class="comment">//_____________________________________________________________________________</span>
<a name="abJDdB"></a><span class="keyword">void</span> <a href="../TUCNGeoCtub.html">TUCNGeoCtub</a>::<a href="../TUCNGeoCtub.html#TUCNGeoCtub:ComputeBBox" title="void TUCNGeoCtub::ComputeBBox()">ComputeBBox</a>()
{
<span class="comment">// compute minimum bounding box of the ctub</span>
   <a href="../TUCNGeoTubeSeg.html">TUCNGeoTubeSeg</a>::<a href="../TUCNGeoTubeSeg.html#TUCNGeoTubeSeg:ComputeBBox" title="void TUCNGeoTubeSeg::ComputeBBox()">ComputeBBox</a>();
   <span class="keyword">if</span> ((<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[2]&gt;-(1E-10)) || (<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[2]&lt;1E-10)) {
      <a href="../#TObject:Error" title="void TObject::Error(const char* method,const char* msgfmt)">Error</a>(<span class="string">"ComputeBBox"</span>, <span class="string">"In shape %s wrong definition of cut planes"</span>, <a href="../#TGeoShape:GetName" title="const char* TGeoShape::GetName()">GetName</a>());
      <span class="keyword">return</span>;
   }
   <a href="../ListOfTypes.html#Double_t">Double_t</a> xc=0, yc=0;
   <a href="../ListOfTypes.html#Double_t">Double_t</a> zmin=0, zmax=0;
   <a href="../ListOfTypes.html#Double_t">Double_t</a> z1;
   <a href="../ListOfTypes.html#Double_t">Double_t</a> z[8];
   <span class="comment">// check if nxy is in the phi range</span>
   <a href="../ListOfTypes.html#Double_t">Double_t</a> phi_low = TMath::ATan2(<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[1], <a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[0]) *TMath::RadToDeg();
   <a href="../ListOfTypes.html#Double_t">Double_t</a> phi_hi = TMath::ATan2(<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[1], <a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[0]) *TMath::RadToDeg();
   <a href="../ListOfTypes.html#Bool_t">Bool_t</a> in_range_low = <a href="../ListOfTypes.html#Bool_t">kFALSE</a>;
   <a href="../ListOfTypes.html#Bool_t">Bool_t</a> in_range_hi = <a href="../ListOfTypes.html#Bool_t">kFALSE</a>;

   <a href="../ListOfTypes.html#Int_t">Int_t</a> i;
   <span class="keyword">for</span> (i=0; i&lt;2; i++) {
      <span class="keyword">if</span> (phi_low&lt;0) phi_low+=360.;
      <a href="../ListOfTypes.html#Double_t">Double_t</a> dphi = fPhi2 -fPhi1;
      <span class="keyword">if</span> (dphi &lt; 0) dphi+=360.;
      <a href="../ListOfTypes.html#Double_t">Double_t</a> ddp = phi_low-fPhi1;
      <span class="keyword">if</span> (ddp&lt;0) ddp += 360.;
      <span class="keyword">if</span> (ddp &lt;= dphi) {
         xc = fRmin*TMath::Cos(phi_low*TMath::DegToRad());
         yc = fRmin*TMath::Sin(phi_low*TMath::DegToRad());
         z1 = <a href="../TUCNGeoCtub.html#TUCNGeoCtub:GetZcoord" title="Double_t TUCNGeoCtub::GetZcoord(Double_t xc,Double_t yc,Double_t zc)">GetZcoord</a>(xc, yc, -fDz);
         xc = fRmax*TMath::Cos(phi_low*TMath::DegToRad());
         yc = fRmax*TMath::Sin(phi_low*TMath::DegToRad());
         z1 = TMath::Min(z1, <a href="../TUCNGeoCtub.html#TUCNGeoCtub:GetZcoord" title="Double_t TUCNGeoCtub::GetZcoord(Double_t xc,Double_t yc,Double_t zc)">GetZcoord</a>(xc, yc, -fDz));
         <span class="keyword">if</span> (in_range_low)
            zmin = TMath::Min(zmin, z1);
         <span class="keyword">else</span>
            zmin = z1;
         in_range_low = <a href="../ListOfTypes.html#Bool_t">kTRUE</a>;
      }
      phi_low += 180;
      <span class="keyword">if</span> (phi_low&gt;360) phi_low-=360.;
   }

   <span class="keyword">for</span> (i=0; i&lt;2; i++) {
      <span class="keyword">if</span> (phi_hi&lt;0) phi_hi+=360.;
      <a href="../ListOfTypes.html#Double_t">Double_t</a> dphi = fPhi2 -fPhi1;
      <span class="keyword">if</span> (dphi &lt; 0) dphi+=360.;
      <a href="../ListOfTypes.html#Double_t">Double_t</a> ddp = phi_hi-fPhi1;
      <span class="keyword">if</span> (ddp&lt;0) ddp += 360.;
      <span class="keyword">if</span> (ddp &lt;= dphi) {
         xc = fRmin*TMath::Cos(phi_hi*TMath::DegToRad());
         yc = fRmin*TMath::Sin(phi_hi*TMath::DegToRad());
         z1 = <a href="../TUCNGeoCtub.html#TUCNGeoCtub:GetZcoord" title="Double_t TUCNGeoCtub::GetZcoord(Double_t xc,Double_t yc,Double_t zc)">GetZcoord</a>(xc, yc, fDz);
         xc = fRmax*TMath::Cos(phi_hi*TMath::DegToRad());
         yc = fRmax*TMath::Sin(phi_hi*TMath::DegToRad());
         z1 = TMath::Max(z1, <a href="../TUCNGeoCtub.html#TUCNGeoCtub:GetZcoord" title="Double_t TUCNGeoCtub::GetZcoord(Double_t xc,Double_t yc,Double_t zc)">GetZcoord</a>(xc, yc, fDz));
         <span class="keyword">if</span> (in_range_hi)
            zmax = TMath::Max(zmax, z1);
         <span class="keyword">else</span>
            zmax = z1;
         in_range_hi = <a href="../ListOfTypes.html#Bool_t">kTRUE</a>;
      }
      phi_hi += 180;
      <span class="keyword">if</span> (phi_hi&gt;360) phi_hi-=360.;
   }


   xc = fRmin*TMath::Cos(fPhi1*TMath::DegToRad());
   yc = fRmin*TMath::Sin(fPhi1*TMath::DegToRad());
   z[0] = <a href="../TUCNGeoCtub.html#TUCNGeoCtub:GetZcoord" title="Double_t TUCNGeoCtub::GetZcoord(Double_t xc,Double_t yc,Double_t zc)">GetZcoord</a>(xc, yc, -fDz);
   z[4] = <a href="../TUCNGeoCtub.html#TUCNGeoCtub:GetZcoord" title="Double_t TUCNGeoCtub::GetZcoord(Double_t xc,Double_t yc,Double_t zc)">GetZcoord</a>(xc, yc, fDz);

   xc = fRmin*TMath::Cos(fPhi2*TMath::DegToRad());
   yc = fRmin*TMath::Sin(fPhi2*TMath::DegToRad());
   z[1] = <a href="../TUCNGeoCtub.html#TUCNGeoCtub:GetZcoord" title="Double_t TUCNGeoCtub::GetZcoord(Double_t xc,Double_t yc,Double_t zc)">GetZcoord</a>(xc, yc, -fDz);
   z[5] = <a href="../TUCNGeoCtub.html#TUCNGeoCtub:GetZcoord" title="Double_t TUCNGeoCtub::GetZcoord(Double_t xc,Double_t yc,Double_t zc)">GetZcoord</a>(xc, yc, fDz);

   xc = fRmax*TMath::Cos(fPhi1*TMath::DegToRad());
   yc = fRmax*TMath::Sin(fPhi1*TMath::DegToRad());
   z[2] = <a href="../TUCNGeoCtub.html#TUCNGeoCtub:GetZcoord" title="Double_t TUCNGeoCtub::GetZcoord(Double_t xc,Double_t yc,Double_t zc)">GetZcoord</a>(xc, yc, -fDz);
   z[6] = <a href="../TUCNGeoCtub.html#TUCNGeoCtub:GetZcoord" title="Double_t TUCNGeoCtub::GetZcoord(Double_t xc,Double_t yc,Double_t zc)">GetZcoord</a>(xc, yc, fDz);

   xc = fRmax*TMath::Cos(fPhi2*TMath::DegToRad());
   yc = fRmax*TMath::Sin(fPhi2*TMath::DegToRad());
   z[3] = <a href="../TUCNGeoCtub.html#TUCNGeoCtub:GetZcoord" title="Double_t TUCNGeoCtub::GetZcoord(Double_t xc,Double_t yc,Double_t zc)">GetZcoord</a>(xc, yc, -fDz);
   z[7] = <a href="../TUCNGeoCtub.html#TUCNGeoCtub:GetZcoord" title="Double_t TUCNGeoCtub::GetZcoord(Double_t xc,Double_t yc,Double_t zc)">GetZcoord</a>(xc, yc, fDz);

   z1 = z[TMath::LocMin(4, &amp;z[0])];
   <span class="keyword">if</span> (in_range_low)
      zmin = TMath::Min(zmin, z1);
   <span class="keyword">else</span>
      zmin = z1;

   z1 = z[TMath::LocMax(4, &amp;z[4])+4];
   <span class="keyword">if</span> (in_range_hi)
      zmax = TMath::Max(zmax, z1);
   <span class="keyword">else</span>
      zmax = z1;

   fDZ = 0.5*(zmax-zmin);
   fOrigin[2] = 0.5*(zmax+zmin);
}

<span class="comment">//_____________________________________________________________________________</span>
<a name="yBw2wC"></a><span class="keyword">void</span> <a href="../TUCNGeoCtub.html">TUCNGeoCtub</a>::<a href="../TUCNGeoCtub.html#TUCNGeoCtub:ComputeNormal" title="void TUCNGeoCtub::ComputeNormal(Double_t* point,Double_t* dir,Double_t* norm)">ComputeNormal</a>(<a href="../ListOfTypes.html#Double_t">Double_t</a> *point, <a href="../ListOfTypes.html#Double_t">Double_t</a> *dir, <a href="../ListOfTypes.html#Double_t">Double_t</a> *norm)
{
<span class="comment">// Compute normal to closest surface from POINT.</span>
   <a href="../ListOfTypes.html#Double_t">Double_t</a> saf[4];
   <a href="../ListOfTypes.html#Bool_t">Bool_t</a> isseg = <a href="../ListOfTypes.html#Bool_t">kTRUE</a>;
   <span class="keyword">if</span> (TMath::Abs(fPhi2-fPhi1-360.)&lt;1E-8) isseg=<a href="../ListOfTypes.html#Bool_t">kFALSE</a>;
   <a href="../ListOfTypes.html#Double_t">Double_t</a> rsq = point[0]*point[0]+point[1]*point[1];
   <a href="../ListOfTypes.html#Double_t">Double_t</a> r = TMath::Sqrt(rsq);

   saf[0] = TMath::Abs(point[0]*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[0] + point[1]*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[1] + (fDz+point[2])*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[2]);
   saf[1] = TMath::Abs(point[0]*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[0] + point[1]*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[1] - (fDz-point[2])*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[2]);
   saf[2] = (fRmin&gt;1E-10)?TMath::Abs(r-fRmin):TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
   saf[3] = TMath::Abs(fRmax-r);
   <a href="../ListOfTypes.html#Int_t">Int_t</a> i = TMath::LocMin(4,saf);
   <span class="keyword">if</span> (isseg) {
      <a href="../ListOfTypes.html#Double_t">Double_t</a> c1 = TMath::Cos(fPhi1*TMath::DegToRad());
      <a href="../ListOfTypes.html#Double_t">Double_t</a> s1 = TMath::Sin(fPhi1*TMath::DegToRad());
      <a href="../ListOfTypes.html#Double_t">Double_t</a> c2 = TMath::Cos(fPhi2*TMath::DegToRad());
      <a href="../ListOfTypes.html#Double_t">Double_t</a> s2 = TMath::Sin(fPhi2*TMath::DegToRad());
      <span class="keyword">if</span> (TGeoShape::<a href="../#TGeoShape:IsCloseToPhi" title="Bool_t TGeoShape::IsCloseToPhi(Double_t epsil,Double_t* point,Double_t c1,Double_t s1,Double_t c2,Double_t s2)">IsCloseToPhi</a>(saf[i], point,c1,s1,c2,s2)) {
         TGeoShape::<a href="../#TGeoShape:NormalPhi" title="void TGeoShape::NormalPhi(Double_t* point,Double_t* dir,Double_t* norm,Double_t c1,Double_t s1,Double_t c2,Double_t s2)">NormalPhi</a>(point,dir,norm,c1,s1,c2,s2);
         <span class="keyword">return</span>;
      }
   }
   <span class="keyword">if</span> (i==0) {
      memcpy(norm, <a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>, 3*<span class="keyword">sizeof</span>(<a href="../ListOfTypes.html#Double_t">Double_t</a>));
      <span class="keyword">if</span> (norm[0]*dir[0]+norm[1]*dir[1]+norm[2]*dir[2]&lt;0) {
         norm[0] = -norm[0];
         norm[1] = -norm[1];
         norm[2] = -norm[2];
      }
      <span class="keyword">return</span>;
   }
   <span class="keyword">if</span> (i==1) {
      memcpy(norm, <a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>, 3*<span class="keyword">sizeof</span>(<a href="../ListOfTypes.html#Double_t">Double_t</a>));
      <span class="keyword">if</span> (norm[0]*dir[0]+norm[1]*dir[1]+norm[2]*dir[2]&lt;0) {
         norm[0] = -norm[0];
         norm[1] = -norm[1];
         norm[2] = -norm[2];
      }
      <span class="keyword">return</span>;
   }

   norm[2] = 0;
   <a href="../ListOfTypes.html#Double_t">Double_t</a> phi = TMath::ATan2(point[1], point[0]);
   norm[0] = TMath::Cos(phi);
   norm[1] = TMath::Sin(phi);
   <span class="keyword">if</span> (norm[0]*dir[0]+norm[1]*dir[1]&lt;0) {
      norm[0] = -norm[0];
      norm[1] = -norm[1];
   }
}

<span class="comment">//_____________________________________________________________________________</span>
<a name="bK9ocC"></a><a href="../ListOfTypes.html#Bool_t">Bool_t</a> <a href="../TUCNGeoCtub.html">TUCNGeoCtub</a>::<a href="../TUCNGeoCtub.html#TUCNGeoCtub:Contains" title="Bool_t TUCNGeoCtub::Contains(Double_t* point)">Contains</a>(<a href="../ListOfTypes.html#Double_t">Double_t</a> *point) <span class="keyword">const</span>
{
<span class="comment">// check if point is contained in the cut tube</span>
   <span class="comment">// check the lower cut plane</span>
   <a href="../ListOfTypes.html#Double_t">Double_t</a> zin = point[0]*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[0]+point[1]*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[1]+(point[2]+fDz)*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[2];
   <span class="keyword">if</span> (zin&gt;0) <span class="keyword">return</span> <a href="../ListOfTypes.html#Bool_t">kFALSE</a>;
   <span class="comment">// check the higher cut plane</span>
   zin = point[0]*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[0]+point[1]*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[1]+(point[2]-fDz)*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[2];
   <span class="keyword">if</span> (zin&gt;0) <span class="keyword">return</span> <a href="../ListOfTypes.html#Bool_t">kFALSE</a>;
   <span class="comment">// check radius</span>
   <a href="../ListOfTypes.html#Double_t">Double_t</a> r2 = point[0]*point[0]+point[1]*point[1];
   <span class="keyword">if</span> ((r2&lt;fRmin*fRmin) || (r2&gt;fRmax*fRmax)) <span class="keyword">return</span> <a href="../ListOfTypes.html#Bool_t">kFALSE</a>;
   <span class="comment">// check phi</span>
   <a href="../ListOfTypes.html#Double_t">Double_t</a> phi = TMath::ATan2(point[1], point[0]) * TMath::RadToDeg();
   <span class="keyword">if</span> (phi &lt; 0 ) phi+=360.;
   <a href="../ListOfTypes.html#Double_t">Double_t</a> dphi = fPhi2 -fPhi1;
   <a href="../ListOfTypes.html#Double_t">Double_t</a> ddp = phi-fPhi1;
   <span class="keyword">if</span> (ddp&lt;0) ddp += 360.;
<span class="comment">//   if (ddp&gt;360) ddp-=360;</span>
   <span class="keyword">if</span> (ddp &gt; dphi) <span class="keyword">return</span> <a href="../ListOfTypes.html#Bool_t">kFALSE</a>;
   <span class="keyword">return</span> <a href="../ListOfTypes.html#Bool_t">kTRUE</a>;
}

<span class="comment">//_____________________________________________________________________________</span>
<a name="Dx9ntE"></a><a href="../ListOfTypes.html#Double_t">Double_t</a> <a href="../TUCNGeoCtub.html">TUCNGeoCtub</a>::<a href="../TUCNGeoCtub.html#TUCNGeoCtub:GetAxisRange" title="Double_t TUCNGeoCtub::GetAxisRange(Int_t iaxis,Double_t&amp; xlo,Double_t&amp; xhi)">GetAxisRange</a>(<a href="../ListOfTypes.html#Int_t">Int_t</a> iaxis, <a href="../ListOfTypes.html#Double_t">Double_t</a> &amp;xlo, <a href="../ListOfTypes.html#Double_t">Double_t</a> &amp;xhi) <span class="keyword">const</span>
{
<span class="comment">// Get range of shape for a given axis.</span>
   xlo = 0;
   xhi = 0;
   <a href="../ListOfTypes.html#Double_t">Double_t</a> dx = 0;
   <span class="keyword">switch</span> (iaxis) {
      <span class="keyword">case</span> 1:
         xlo = fRmin;
         xhi = fRmax;
         dx = xhi-xlo;
         <span class="keyword">return</span> dx;
      <span class="keyword">case</span> 2:
         xlo = fPhi1;
         xhi = fPhi2;
         dx = xhi-xlo;
         <span class="keyword">return</span> dx;
   }
   <span class="keyword">return</span> dx;
}

<span class="comment">//_____________________________________________________________________________</span>
<a name="ZVzVFD"></a><a href="../ListOfTypes.html#Double_t">Double_t</a> <a href="../TUCNGeoCtub.html">TUCNGeoCtub</a>::<a href="../TUCNGeoCtub.html#TUCNGeoCtub:GetZcoord" title="Double_t TUCNGeoCtub::GetZcoord(Double_t xc,Double_t yc,Double_t zc)">GetZcoord</a>(<a href="../ListOfTypes.html#Double_t">Double_t</a> xc, <a href="../ListOfTypes.html#Double_t">Double_t</a> yc, <a href="../ListOfTypes.html#Double_t">Double_t</a> zc) <span class="keyword">const</span>
{
<span class="comment">// compute real Z coordinate of a point belonging to either lower or</span>
<span class="comment">// higher caps (z should be either +fDz or -fDz)</span>
   <a href="../ListOfTypes.html#Double_t">Double_t</a> newz = 0;
   <span class="keyword">if</span> (zc&lt;0) newz =  -fDz-(xc*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[0]+yc*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[1])/<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[2];
   <span class="keyword">else</span>      newz = fDz-(xc*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[0]+yc*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[1])/<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[2];
   <span class="keyword">return</span> newz;
}

<span class="comment">//_____________________________________________________________________________</span>
<a name="GWSZfC"></a><a href="../ListOfTypes.html#Double_t">Double_t</a> <a href="../TUCNGeoCtub.html">TUCNGeoCtub</a>::<a href="../TUCNGeoCtub.html#TUCNGeoCtub:DistFromOutside" title="Double_t TUCNGeoCtub::DistFromOutside(Double_t* point,Double_t* dir,Int_t iact=1,Double_t step=TGeoShape::Big(),Double_t* safe=0)">DistFromOutside</a>(<a href="../ListOfTypes.html#Double_t">Double_t</a> *point, <a href="../ListOfTypes.html#Double_t">Double_t</a> *dir, <a href="../ListOfTypes.html#Int_t">Int_t</a> iact, <a href="../ListOfTypes.html#Double_t">Double_t</a> step, <a href="../ListOfTypes.html#Double_t">Double_t</a> *safe) <span class="keyword">const</span>
{
<span class="comment">// compute distance from outside point to surface of the cut tube</span>
   <span class="keyword">if</span> (iact&lt;3 &amp;&amp; safe) {
      *safe = <a href="../TUCNGeoCtub.html#TUCNGeoCtub:Safety" title="Double_t TUCNGeoCtub::Safety(Double_t* point,Bool_t in=kTRUE)">Safety</a>(point, <a href="../ListOfTypes.html#Bool_t">kFALSE</a>);
      <span class="keyword">if</span> (iact==0) <span class="keyword">return</span> TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
      <span class="keyword">if</span> ((iact==1) &amp;&amp; (step&lt;=*safe)) <span class="keyword">return</span> TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
   }
<span class="comment">// Check if the bounding box is crossed within the requested distance</span>
   <a href="../ListOfTypes.html#Double_t">Double_t</a> sdist = <a href="../TUCNGeoBBox.html">TUCNGeoBBox</a>::<a href="../#TGeoBBox:DistFromOutside" title="Double_t TGeoBBox::DistFromOutside(Double_t* point,Double_t* dir,Int_t iact=1,Double_t step=TGeoShape::Big(),Double_t* safe=0) or overloads">DistFromOutside</a>(point,dir, fDX, fDY, fDZ, fOrigin, step);
   <span class="keyword">if</span> (sdist&gt;=step) <span class="keyword">return</span> TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
   <a href="../ListOfTypes.html#Double_t">Double_t</a> saf[2];
   saf[0] = point[0]*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[0] + point[1]*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[1] + (fDz+point[2])*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[2];
   saf[1] = point[0]*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[0] + point[1]*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[1] + (point[2]-fDz)*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[2];
   <a href="../ListOfTypes.html#Double_t">Double_t</a> rsq = point[0]*point[0]+point[1]*point[1];
   <a href="../ListOfTypes.html#Double_t">Double_t</a> r = TMath::Sqrt(rsq);
   <a href="../ListOfTypes.html#Double_t">Double_t</a> c1=0,s1=0,c2=0,s2=0;
   <a href="../ListOfTypes.html#Double_t">Double_t</a> fio=0, cfio=0, sfio=0, dfi=0, cdfi=0, cpsi=0;
   <a href="../ListOfTypes.html#Double_t">Double_t</a> phi1 = fPhi1*TMath::DegToRad();
   <a href="../ListOfTypes.html#Double_t">Double_t</a> phi2 = fPhi2*TMath::DegToRad();
   <a href="../ListOfTypes.html#Bool_t">Bool_t</a> tub = <a href="../ListOfTypes.html#Bool_t">kFALSE</a>;
   <span class="keyword">if</span> (TMath::Abs(fPhi2-fPhi1-360.)&lt;1E-8) tub = <a href="../ListOfTypes.html#Bool_t">kTRUE</a>;
   <span class="keyword">if</span> (!tub) {
      c1   = TMath::Cos(phi1);
      c2   = TMath::Cos(phi2);
      s1   = TMath::Sin(phi1);
      s2   = TMath::Sin(phi2);
      fio  = 0.5*(phi1+phi2);
      cfio = TMath::Cos(fio);
      sfio = TMath::Sin(fio);
      dfi  = 0.5*(phi2-phi1);
      cdfi = TMath::Cos(dfi);
   }

   <span class="comment">// find distance to shape</span>
   <a href="../ListOfTypes.html#Double_t">Double_t</a> r2;
   <a href="../ListOfTypes.html#Double_t">Double_t</a> calf = dir[0]*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[0]+dir[1]*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[1]+dir[2]*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[2];
   <span class="comment">// check Z planes</span>
   <a href="../ListOfTypes.html#Double_t">Double_t</a> xi, yi, zi;
   <a href="../ListOfTypes.html#Double_t">Double_t</a> s = TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
   <span class="keyword">if</span> (saf[0]&gt;0) {
      <span class="keyword">if</span> (calf&lt;0) {
         s = -saf[0]/calf;
         xi = point[0]+s*dir[0];
         yi = point[1]+s*dir[1];
         r2=xi*xi+yi*yi;
         <span class="keyword">if</span> (((fRmin*fRmin)&lt;=r2) &amp;&amp; (r2&lt;=(fRmax*fRmax))) {
            <span class="keyword">if</span> (tub) <span class="keyword">return</span> s;
            cpsi=(xi*cfio+yi*sfio)/TMath::Sqrt(r2);
            <span class="keyword">if</span> (cpsi&gt;=cdfi) <span class="keyword">return</span> s;
         }
      }
   }
   calf = dir[0]*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[0]+dir[1]*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[1]+dir[2]*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[2];
   <span class="keyword">if</span> (saf[1]&gt;0) {
      <span class="keyword">if</span> (calf&lt;0) {
         s = -saf[1]/calf;
         xi = point[0]+s*dir[0];
         yi = point[1]+s*dir[1];
         r2=xi*xi+yi*yi;
         <span class="keyword">if</span> (((fRmin*fRmin)&lt;=r2) &amp;&amp; (r2&lt;=(fRmax*fRmax))) {
            <span class="keyword">if</span> (tub) <span class="keyword">return</span> s;
            cpsi=(xi*cfio+yi*sfio)/TMath::Sqrt(r2);
            <span class="keyword">if</span> (cpsi&gt;=cdfi) <span class="keyword">return</span> s;
         }
      }
   }

   <span class="comment">// check outer cyl. surface</span>
   <a href="../ListOfTypes.html#Double_t">Double_t</a> nsq=dir[0]*dir[0]+dir[1]*dir[1];
   <span class="keyword">if</span> (TMath::Abs(nsq)&lt;1E-10) <span class="keyword">return</span> TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
   <a href="../ListOfTypes.html#Double_t">Double_t</a> rdotn=point[0]*dir[0]+point[1]*dir[1];
   <a href="../ListOfTypes.html#Double_t">Double_t</a> b,d;
   <span class="comment">// only r&gt;fRmax has to be considered</span>
   <span class="keyword">if</span> (r&gt;fRmax) {
      <a href="../TUCNGeoTube.html">TUCNGeoTube</a>::<a href="../TUCNGeoTube.html#TUCNGeoTube:DistToTube" title="void TUCNGeoTube::DistToTube(Double_t rsq,Double_t nsq,Double_t rdotn,Double_t radius,Double_t&amp; b,Double_t&amp; delta)">DistToTube</a>(rsq, nsq, rdotn, fRmax, b, d);
      <span class="keyword">if</span> (d&gt;0) {
         s=-b-d;
         <span class="keyword">if</span> (s&gt;0) {
            xi=point[0]+s*dir[0];
            yi=point[1]+s*dir[1];
            zi=point[2]+s*dir[2];
            <span class="keyword">if</span> ((-xi*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[0]-yi*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[1]-(zi+fDz)*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[2])&gt;0) {
               <span class="keyword">if</span> ((-xi*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[0]-yi*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[1]+(fDz-zi)*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[2])&gt;0) {
                  <span class="keyword">if</span> (tub) <span class="keyword">return</span> s;
                  cpsi=(xi*cfio+yi*sfio)/fRmax;
                  <span class="keyword">if</span> (cpsi&gt;=cdfi) <span class="keyword">return</span> s;
               }
            }
         }
      }
   }
   <span class="comment">// check inner cylinder</span>
   <a href="../ListOfTypes.html#Double_t">Double_t</a> snxt=TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
   <span class="keyword">if</span> (fRmin&gt;0) {
      <a href="../TUCNGeoTube.html">TUCNGeoTube</a>::<a href="../TUCNGeoTube.html#TUCNGeoTube:DistToTube" title="void TUCNGeoTube::DistToTube(Double_t rsq,Double_t nsq,Double_t rdotn,Double_t radius,Double_t&amp; b,Double_t&amp; delta)">DistToTube</a>(rsq, nsq, rdotn, fRmin, b, d);
      <span class="keyword">if</span> (d&gt;0) {
         s=-b+d;
         <span class="keyword">if</span> (s&gt;0) {
            xi=point[0]+s*dir[0];
            yi=point[1]+s*dir[1];
            zi=point[2]+s*dir[2];
            <span class="keyword">if</span> ((-xi*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[0]-yi*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[1]-(zi+fDz)*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[2])&gt;0) {
               <span class="keyword">if</span> ((-xi*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[0]-yi*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[1]+(fDz-zi)*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[2])&gt;0) {
                  <span class="keyword">if</span> (tub) <span class="keyword">return</span> s;
                  cpsi=(xi*cfio+yi*sfio)/fRmin;
                  <span class="keyword">if</span> (cpsi&gt;=cdfi) snxt=s;
               }
            }
         }
      }
   }
   <span class="comment">// check phi planes</span>
   <span class="keyword">if</span> (tub) <span class="keyword">return</span> snxt;
   <a href="../ListOfTypes.html#Double_t">Double_t</a> un=dir[0]*s1-dir[1]*c1;
   <span class="keyword">if</span> (un != 0) {
      s=(point[1]*c1-point[0]*s1)/un;
      <span class="keyword">if</span> (s&gt;=0) {
         xi=point[0]+s*dir[0];
         yi=point[1]+s*dir[1];
         zi=point[2]+s*dir[2];
         <span class="keyword">if</span> ((-xi*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[0]-yi*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[1]-(zi+fDz)*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[2])&gt;0) {
            <span class="keyword">if</span> ((-xi*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[0]-yi*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[1]+(fDz-zi)*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[2])&gt;0) {
               r2=xi*xi+yi*yi;
               <span class="keyword">if</span> ((fRmin*fRmin&lt;=r2) &amp;&amp; (r2&lt;=fRmax*fRmax)) {
                  <span class="keyword">if</span> ((yi*cfio-xi*sfio)&lt;=0) {
                     <span class="keyword">if</span> (s&lt;snxt) snxt=s;
                  }
               }
            }
         }
      }
   }
   un=dir[0]*s2-dir[1]*c2;
   <span class="keyword">if</span> (un != 0) {
      s=(point[1]*c2-point[0]*s2)/un;
      <span class="keyword">if</span> (s&gt;=0) {
         xi=point[0]+s*dir[0];
         yi=point[1]+s*dir[1];
         zi=point[2]+s*dir[2];
         <span class="keyword">if</span> ((-xi*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[0]-yi*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[1]-(zi+fDz)*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[2])&gt;0) {
            <span class="keyword">if</span> ((-xi*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[0]-yi*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[1]+(fDz-zi)*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[2])&gt;0) {
               r2=xi*xi+yi*yi;
               <span class="keyword">if</span> ((fRmin*fRmin&lt;=r2) &amp;&amp; (r2&lt;=fRmax*fRmax)) {
                  <span class="keyword">if</span> ((yi*cfio-xi*sfio)&gt;=0) {
                     <span class="keyword">if</span> (s&lt;snxt) snxt=s;
                  }
               }
            }
         }
      }
   }
   <span class="keyword">return</span> snxt;
}

<span class="comment">//_____________________________________________________________________________</span>
<a name="r_iwW"></a><a href="../ListOfTypes.html#Double_t">Double_t</a> <a href="../TUCNGeoCtub.html">TUCNGeoCtub</a>::<a href="../TUCNGeoCtub.html#TUCNGeoCtub:DistFromInside" title="Double_t TUCNGeoCtub::DistFromInside(Double_t* point,Double_t* dir,Int_t iact=1,Double_t step=TGeoShape::Big(),Double_t* safe=0)">DistFromInside</a>(<a href="../ListOfTypes.html#Double_t">Double_t</a> *point, <a href="../ListOfTypes.html#Double_t">Double_t</a> *dir, <a href="../ListOfTypes.html#Int_t">Int_t</a> iact, <a href="../ListOfTypes.html#Double_t">Double_t</a> step, <a href="../ListOfTypes.html#Double_t">Double_t</a> *safe) <span class="keyword">const</span>
{
<span class="comment">// compute distance from inside point to surface of the cut tube</span>
   <span class="keyword">if</span> (iact&lt;3 &amp;&amp; safe) *safe = <a href="../TUCNGeoCtub.html#TUCNGeoCtub:Safety" title="Double_t TUCNGeoCtub::Safety(Double_t* point,Bool_t in=kTRUE)">Safety</a>(point, <a href="../ListOfTypes.html#Bool_t">kTRUE</a>);
   <span class="keyword">if</span> (iact==0) <span class="keyword">return</span> TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
   <span class="keyword">if</span> ((iact==1) &amp;&amp; (*safe&gt;step)) <span class="keyword">return</span> TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
   <a href="../ListOfTypes.html#Double_t">Double_t</a> rsq = point[0]*point[0]+point[1]*point[1];
   <a href="../ListOfTypes.html#Double_t">Double_t</a> c1=0,s1=0,c2=0,s2=0,cm=0,sm=0,phim=0;
   <a href="../ListOfTypes.html#Double_t">Double_t</a> phi1 = fPhi1*TMath::DegToRad();
   <a href="../ListOfTypes.html#Double_t">Double_t</a> phi2 = fPhi2*TMath::DegToRad();
   <a href="../ListOfTypes.html#Bool_t">Bool_t</a> tub = <a href="../ListOfTypes.html#Bool_t">kFALSE</a>;
   <span class="keyword">if</span> (TMath::Abs(fPhi2-fPhi1-360.)&lt;1E-8) tub = <a href="../ListOfTypes.html#Bool_t">kTRUE</a>;
   <span class="keyword">if</span> (!tub) {
      <span class="keyword">if</span> (phi2&lt;phi1) phi2+=2.*TMath::Pi();
      phim = 0.5*(phi1+phi2);
      c1 = TMath::Cos(phi1);
      c2 = TMath::Cos(phi2);
      s1 = TMath::Sin(phi1);
      s2 = TMath::Sin(phi2);
      cm = TMath::Cos(phim);
      sm = TMath::Sin(phim);
   }
   <span class="comment">// compute distance to surface</span>
   <span class="comment">// Do Z</span>
   <a href="../ListOfTypes.html#Double_t">Double_t</a> sz = TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
   <a href="../ListOfTypes.html#Double_t">Double_t</a> saf[2];
   saf[0] = -point[0]*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[0] - point[1]*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[1] - (fDz+point[2])*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[2];
   saf[1] = -point[0]*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[0] - point[1]*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[1] + (fDz-point[2])*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[2];
   <a href="../ListOfTypes.html#Double_t">Double_t</a> calf = dir[0]*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[0]+dir[1]*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[1]+dir[2]*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[2];
   <span class="keyword">if</span> (calf&gt;0) sz = saf[0]/calf;

   <a href="../ListOfTypes.html#Double_t">Double_t</a> sz1=TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
   calf = dir[0]*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[0]+dir[1]*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[1]+dir[2]*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[2];
   <span class="keyword">if</span> (calf&gt;0) {
      sz1 = saf[1]/calf;
      <span class="keyword">if</span> (sz1&lt;sz) sz = sz1;
   }

   <span class="comment">// Do R</span>
   <a href="../ListOfTypes.html#Double_t">Double_t</a> nsq=dir[0]*dir[0]+dir[1]*dir[1];
   <span class="comment">// track parallel to Z</span>
   <span class="keyword">if</span> (TMath::Abs(nsq)&lt;1E-10) <span class="keyword">return</span> sz;
   <a href="../ListOfTypes.html#Double_t">Double_t</a> rdotn=point[0]*dir[0]+point[1]*dir[1];
   <a href="../ListOfTypes.html#Double_t">Double_t</a> sr=TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
   <a href="../ListOfTypes.html#Double_t">Double_t</a> b, d;
   <a href="../ListOfTypes.html#Bool_t">Bool_t</a> skip_outer = <a href="../ListOfTypes.html#Bool_t">kFALSE</a>;
   <span class="comment">// inner cylinder</span>
   <span class="keyword">if</span> (fRmin&gt;1E-10) {
      <a href="../TUCNGeoTube.html">TUCNGeoTube</a>::<a href="../TUCNGeoTube.html#TUCNGeoTube:DistToTube" title="void TUCNGeoTube::DistToTube(Double_t rsq,Double_t nsq,Double_t rdotn,Double_t radius,Double_t&amp; b,Double_t&amp; delta)">DistToTube</a>(rsq, nsq, rdotn, fRmin, b, d);
      <span class="keyword">if</span> (d&gt;0) {
         sr=-b-d;
         <span class="keyword">if</span> (sr&gt;0) skip_outer = <a href="../ListOfTypes.html#Bool_t">kTRUE</a>;
      }
   }
   <span class="comment">// outer cylinder</span>
   <span class="keyword">if</span> (!skip_outer) {
      <a href="../TUCNGeoTube.html">TUCNGeoTube</a>::<a href="../TUCNGeoTube.html#TUCNGeoTube:DistToTube" title="void TUCNGeoTube::DistToTube(Double_t rsq,Double_t nsq,Double_t rdotn,Double_t radius,Double_t&amp; b,Double_t&amp; delta)">DistToTube</a>(rsq, nsq, rdotn, fRmax, b, d);
      <span class="keyword">if</span> (d&gt;0) {
         sr=-b+d;
         <span class="keyword">if</span> (sr&lt;0) sr=TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
      } <span class="keyword">else</span> {
         <a href="../#TObject:Error" title="void TObject::Error(const char* method,const char* msgfmt)">Error</a>(<span class="string">"DistFromInside"</span>, <span class="string">"In shape %s cannot get outside !"</span>, <a href="../#TGeoShape:GetName" title="const char* TGeoShape::GetName()">GetName</a>());
      }
   }
   <span class="comment">// phi planes</span>
   <a href="../ListOfTypes.html#Double_t">Double_t</a> sfmin = TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
   <span class="keyword">if</span> (!tub) sfmin=TGeoShape::<a href="../#TGeoShape:DistToPhiMin" title="Double_t TGeoShape::DistToPhiMin(Double_t* point,Double_t* dir,Double_t s1,Double_t c1,Double_t s2,Double_t c2,Double_t sm,Double_t cm,Bool_t in=kTRUE)">DistToPhiMin</a>(point, dir, s1, c1, s2, c2, sm, cm);
   <span class="keyword">return</span> TMath::Min(TMath::Min(sz,sr), sfmin);
}

<span class="comment">//_____________________________________________________________________________</span>
<a name="k9chV"></a>TGeoVolume *<a href="../TUCNGeoCtub.html">TUCNGeoCtub</a>::<a href="../TUCNGeoCtub.html#TUCNGeoCtub:Divide" title="TGeoVolume* TUCNGeoCtub::Divide(TGeoVolume* voldiv,const char* divname,Int_t iaxis,Int_t ndiv,Double_t start,Double_t step)">Divide</a>(TGeoVolume * <span class="comment">/*voldiv*/</span>, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="comment">/*divname*/</span>, <a href="../ListOfTypes.html#Int_t">Int_t</a> <span class="comment">/*iaxis*/</span>, <a href="../ListOfTypes.html#Int_t">Int_t</a> <span class="comment">/*ndiv*/</span>,
                             <a href="../ListOfTypes.html#Double_t">Double_t</a> <span class="comment">/*start*/</span>, <a href="../ListOfTypes.html#Double_t">Double_t</a> <span class="comment">/*step*/</span>)
{
<span class="comment">// <a href="../TUCNGeoCtub.html#TUCNGeoCtub:Divide" title="TGeoVolume* TUCNGeoCtub::Divide(TGeoVolume* voldiv,const char* divname,Int_t iaxis,Int_t ndiv,Double_t start,Double_t step)">Divide</a> the tube along one axis.</span>
   <a href="../#TObject:Warning" title="void TObject::Warning(const char* method,const char* msgfmt)">Warning</a>(<span class="string">"Divide"</span>, <span class="string">"In shape %s division of a cut tube not implemented"</span>, <a href="../#TGeoShape:GetName" title="const char* TGeoShape::GetName()">GetName</a>());
   <span class="keyword">return</span> 0;
}

<span class="comment">//_____________________________________________________________________________</span>
<a name="m3KSS"></a>TGeoShape *<a href="../TUCNGeoCtub.html">TUCNGeoCtub</a>::<a href="../TUCNGeoCtub.html#TUCNGeoCtub:GetMakeRuntimeShape" title="TGeoShape* TUCNGeoCtub::GetMakeRuntimeShape(TGeoShape* mother,TGeoMatrix* mat)">GetMakeRuntimeShape</a>(TGeoShape *mother, TGeoMatrix * <span class="comment">/*mat*/</span>) <span class="keyword">const</span>
{
<span class="comment">// in case shape has some negative parameters, these has to be computed</span>
<span class="comment">// in order to fit the mother</span>
   <span class="keyword">if</span> (!<a href="../#TGeoShape:TestShapeBit" title="Bool_t TGeoShape::TestShapeBit(UInt_t f)">TestShapeBit</a>(kGeoRunTimeShape)) <span class="keyword">return</span> 0;
   <span class="keyword">if</span> (!mother-&gt;<a href="../#TGeoShape:TestShapeBit" title="Bool_t TGeoShape::TestShapeBit(UInt_t f)">TestShapeBit</a>(kGeoTube)) {
      <a href="../#TObject:Error" title="void TObject::Error(const char* method,const char* msgfmt)">Error</a>(<span class="string">"GetMakeRuntimeShape"</span>, <span class="string">"Invalid mother for shape %s"</span>, <a href="../#TGeoShape:GetName" title="const char* TGeoShape::GetName()">GetName</a>());
      <span class="keyword">return</span> 0;
   }
   <a href="../ListOfTypes.html#Double_t">Double_t</a> rmin, rmax, dz;
   rmin = fRmin;
   rmax = fRmax;
   dz = fDz;
   <span class="keyword">if</span> (fDz&lt;0) dz=((<a href="../TUCNGeoTube.html">TUCNGeoTube</a>*)mother)-&gt;<a href="../TUCNGeoTube.html#TUCNGeoTube:GetDz" title="Double_t TUCNGeoTube::GetDz()">GetDz</a>();
   <span class="keyword">if</span> (fRmin&lt;0)
      rmin = ((<a href="../TUCNGeoTube.html">TUCNGeoTube</a>*)mother)-&gt;<a href="../TUCNGeoTube.html#TUCNGeoTube:GetRmin" title="Double_t TUCNGeoTube::GetRmin()">GetRmin</a>();
   <span class="keyword">if</span> ((fRmax&lt;0) || (fRmax&lt;=fRmin))
      rmax = ((<a href="../TUCNGeoTube.html">TUCNGeoTube</a>*)mother)-&gt;<a href="../TUCNGeoTube.html#TUCNGeoTube:GetRmax" title="Double_t TUCNGeoTube::GetRmax()">GetRmax</a>();

   <span class="keyword">return</span> (<span class="keyword">new</span> <a href="../TUCNGeoCtub.html">TUCNGeoCtub</a>(rmin, rmax, dz, fPhi1, fPhi2, <a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[0], <a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[1], <a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[2],
                        <a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[0], <a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[1], <a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[2]));
}

<span class="comment">//_____________________________________________________________________________</span>
<a name="LTZmkE"></a><span class="keyword">void</span> <a href="../TUCNGeoCtub.html">TUCNGeoCtub</a>::<a href="../TUCNGeoCtub.html#TUCNGeoCtub:InspectShape" title="void TUCNGeoCtub::InspectShape()">InspectShape</a>() <span class="keyword">const</span>
{
<span class="comment">// print shape parameters</span>
   printf(<span class="string">"*** Shape %s: TUCNGeoCtub ***\n"</span>, <a href="../#TGeoShape:GetName" title="const char* TGeoShape::GetName()">GetName</a>());
   printf(<span class="string">"    lx = %11.5f\n"</span>, <a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[0]);
   printf(<span class="string">"    ly = %11.5f\n"</span>, <a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[1]);
   printf(<span class="string">"    lz = %11.5f\n"</span>, <a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[2]);
   printf(<span class="string">"    tx = %11.5f\n"</span>, <a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[0]);
   printf(<span class="string">"    ty = %11.5f\n"</span>, <a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[1]);
   printf(<span class="string">"    tz = %11.5f\n"</span>, <a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[2]);
   <a href="../TUCNGeoTubeSeg.html">TUCNGeoTubeSeg</a>::<a href="../TUCNGeoTubeSeg.html#TUCNGeoTubeSeg:InspectShape" title="void TUCNGeoTubeSeg::InspectShape()">InspectShape</a>();
}

<span class="comment">//_____________________________________________________________________________</span>
<a name="zC6dS"></a><a href="../ListOfTypes.html#Double_t">Double_t</a> <a href="../TUCNGeoCtub.html">TUCNGeoCtub</a>::<a href="../TUCNGeoCtub.html#TUCNGeoCtub:Safety" title="Double_t TUCNGeoCtub::Safety(Double_t* point,Bool_t in=kTRUE)">Safety</a>(<a href="../ListOfTypes.html#Double_t">Double_t</a> *point, <a href="../ListOfTypes.html#Bool_t">Bool_t</a> in) <span class="keyword">const</span>
{
<span class="comment">// computes the closest distance from given point to this shape, according</span>
<span class="comment">// to option. The matching point on the shape is stored in spoint.</span>
   <a href="../ListOfTypes.html#Double_t">Double_t</a> saf[4];
   <a href="../ListOfTypes.html#Double_t">Double_t</a> rsq = point[0]*point[0]+point[1]*point[1];
   <a href="../ListOfTypes.html#Double_t">Double_t</a> r = TMath::Sqrt(rsq);
   <a href="../ListOfTypes.html#Bool_t">Bool_t</a> isseg = <a href="../ListOfTypes.html#Bool_t">kTRUE</a>;
   <span class="keyword">if</span> (TMath::Abs(fPhi2-fPhi1-360.)&lt;1E-8) isseg=<a href="../ListOfTypes.html#Bool_t">kFALSE</a>;

   saf[0] = -point[0]*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[0] - point[1]*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[1] - (fDz+point[2])*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[2];
   saf[1] = -point[0]*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[0] - point[1]*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[1] + (fDz-point[2])*<a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[2];
   saf[2] = (fRmin&lt;1E-10 &amp;&amp; !isseg)?TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>():(r-fRmin);
   saf[3] = fRmax-r;
   <a href="../ListOfTypes.html#Double_t">Double_t</a> safphi = TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
   <a href="../ListOfTypes.html#Double_t">Double_t</a> safe = TGeoShape::<a href="../#TGeoShape:Big" title="Double_t TGeoShape::Big()">Big</a>();
   <span class="keyword">if</span> (isseg) safphi =  TGeoShape::<a href="../#TGeoShape:SafetyPhi" title="Double_t TGeoShape::SafetyPhi(Double_t* point,Bool_t in,Double_t phi1,Double_t phi2)">SafetyPhi</a>(point, in, fPhi1, fPhi2);

   <span class="keyword">if</span> (in) {
      safe = saf[TMath::LocMin(4,saf)];
      <span class="keyword">return</span> TMath::Min(safe, safphi);
   }
   <span class="keyword">for</span> (<a href="../ListOfTypes.html#Int_t">Int_t</a> i=0; i&lt;4; i++) saf[i]=-saf[i];
   safe = saf[TMath::LocMax(4,saf)];
   <span class="keyword">if</span> (isseg) <span class="keyword">return</span> TMath::Max(safe, safphi);
   <span class="keyword">return</span> safe;
}

<span class="comment">//_____________________________________________________________________________</span>
<a name="hrlMSB"></a><span class="keyword">void</span> <a href="../TUCNGeoCtub.html">TUCNGeoCtub</a>::<a href="../TUCNGeoCtub.html#TUCNGeoCtub:SetCtubDimensions" title="void TUCNGeoCtub::SetCtubDimensions(Double_t rmin,Double_t rmax,Double_t dz,Double_t phi1,Double_t phi2,Double_t lx,Double_t ly,Double_t lz,Double_t tx,Double_t ty,Double_t tz)">SetCtubDimensions</a>(<a href="../ListOfTypes.html#Double_t">Double_t</a> rmin, <a href="../ListOfTypes.html#Double_t">Double_t</a> rmax, <a href="../ListOfTypes.html#Double_t">Double_t</a> dz, <a href="../ListOfTypes.html#Double_t">Double_t</a> phi1, <a href="../ListOfTypes.html#Double_t">Double_t</a> phi2,
                   <a href="../ListOfTypes.html#Double_t">Double_t</a> lx, <a href="../ListOfTypes.html#Double_t">Double_t</a> ly, <a href="../ListOfTypes.html#Double_t">Double_t</a> lz, <a href="../ListOfTypes.html#Double_t">Double_t</a> tx, <a href="../ListOfTypes.html#Double_t">Double_t</a> ty, <a href="../ListOfTypes.html#Double_t">Double_t</a> tz)
{
<span class="comment">// set dimensions of a cut tube</span>
   <a href="../TUCNGeoTubeSeg.html#TUCNGeoTubeSeg:SetTubsDimensions" title="void TUCNGeoTubeSeg::SetTubsDimensions(Double_t rmin,Double_t rmax,Double_t dz,Double_t phi1,Double_t phi2)">SetTubsDimensions</a>(rmin, rmax, dz, phi1, phi2);
   <a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[0] = lx;
   <a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[1] = ly;
   <a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[2] = lz;
   <a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[0] = tx;
   <a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[1] = ty;
   <a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[2] = tz;
   <a href="../TUCNGeoCtub.html#TUCNGeoCtub:ComputeBBox" title="void TUCNGeoCtub::ComputeBBox()">ComputeBBox</a>();
}

<span class="comment">//_____________________________________________________________________________</span>
<a name="YeIjcD"></a><span class="keyword">void</span> <a href="../TUCNGeoCtub.html">TUCNGeoCtub</a>::<a href="../TUCNGeoCtub.html#TUCNGeoCtub:SavePrimitive" title="void TUCNGeoCtub::SavePrimitive(ostream&amp; out,Option_t* option=&quot;&quot;)">SavePrimitive</a>(<a href="../ListOfTypes.html#ostream">ostream</a> &amp;out, <a href="../ListOfTypes.html#Option_t">Option_t</a> * <span class="comment">/*option*/</span> <span class="comment">/*= <span class="string">""</span>*/</span>)
{
<span class="comment">// Save a primitive as a C++ statement(s) on output stream <span class="string">"out"</span>.</span>
   <span class="keyword">if</span> (<a href="../#TObject:TObject" title="TObject TObject::TObject() or overloads">TObject</a>::<a href="../#TObject:TestBit" title="Bool_t TObject::TestBit(UInt_t f)">TestBit</a>(kGeoSavePrimitive)) <span class="keyword">return</span>;
   out &lt;&lt; <span class="string">"   // Shape: "</span> &lt;&lt; <a href="../#TGeoShape:GetName" title="const char* TGeoShape::GetName()">GetName</a>() &lt;&lt; <span class="string">" type: "</span> &lt;&lt; <a href="../#TObject:ClassName" title="const char* TObject::ClassName()">ClassName</a>() &lt;&lt; endl;
   out &lt;&lt; <span class="string">"   rmin = "</span> &lt;&lt; fRmin &lt;&lt; <span class="string">";"</span> &lt;&lt; endl;
   out &lt;&lt; <span class="string">"   rmax = "</span> &lt;&lt; fRmax &lt;&lt; <span class="string">";"</span> &lt;&lt; endl;
   out &lt;&lt; <span class="string">"   dz   = "</span> &lt;&lt; fDz &lt;&lt; <span class="string">";"</span> &lt;&lt; endl;
   out &lt;&lt; <span class="string">"   phi1 = "</span> &lt;&lt; fPhi1 &lt;&lt; <span class="string">";"</span> &lt;&lt; endl;
   out &lt;&lt; <span class="string">"   phi2 = "</span> &lt;&lt; fPhi2 &lt;&lt; <span class="string">";"</span> &lt;&lt; endl;
   out &lt;&lt; <span class="string">"   lx   = "</span> &lt;&lt; <a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[0] &lt;&lt; <span class="string">";"</span> &lt;&lt; endl;
   out &lt;&lt; <span class="string">"   ly   = "</span> &lt;&lt; <a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[1] &lt;&lt; <span class="string">";"</span> &lt;&lt; endl;
   out &lt;&lt; <span class="string">"   lz   = "</span> &lt;&lt; <a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[2] &lt;&lt; <span class="string">";"</span> &lt;&lt; endl;
   out &lt;&lt; <span class="string">"   tx   = "</span> &lt;&lt; <a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[0] &lt;&lt; <span class="string">";"</span> &lt;&lt; endl;
   out &lt;&lt; <span class="string">"   ty   = "</span> &lt;&lt; <a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[1] &lt;&lt; <span class="string">";"</span> &lt;&lt; endl;
   out &lt;&lt; <span class="string">"   tz   = "</span> &lt;&lt; <a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[2] &lt;&lt; <span class="string">";"</span> &lt;&lt; endl;
   out &lt;&lt; <span class="string">"   TGeoShape *"</span> &lt;&lt; <a href="../#TGeoShape:GetPointerName" title="char* TGeoShape::GetPointerName()">GetPointerName</a>() &lt;&lt; <span class="string">" = new TUCNGeoCtub(\""</span> &lt;&lt; <a href="../#TGeoShape:GetName" title="const char* TGeoShape::GetName()">GetName</a>() &lt;&lt; <span class="string">"\",rmin,rmax,dz,phi1,phi2,lx,ly,lz,tx,ty,tz);"</span> &lt;&lt; endl;   <a href="../#TObject:TObject" title="TObject TObject::TObject() or overloads">TObject</a>::<a href="../#TObject:SetBit" title="void TObject::SetBit(UInt_t f,Bool_t set) or overloads">SetBit</a>(TGeoShape::kGeoSavePrimitive);
}

<span class="comment">//_____________________________________________________________________________</span>
<a name="W6IybE"></a><span class="keyword">void</span> <a href="../TUCNGeoCtub.html">TUCNGeoCtub</a>::<a href="../TUCNGeoCtub.html#TUCNGeoCtub:SetDimensions" title="void TUCNGeoCtub::SetDimensions(Double_t* param)">SetDimensions</a>(<a href="../ListOfTypes.html#Double_t">Double_t</a> *param)
{
<span class="comment">// Set dimensions of the cut tube starting from a list.</span>
   <a href="../TUCNGeoCtub.html#TUCNGeoCtub:SetCtubDimensions" title="void TUCNGeoCtub::SetCtubDimensions(Double_t rmin,Double_t rmax,Double_t dz,Double_t phi1,Double_t phi2,Double_t lx,Double_t ly,Double_t lz,Double_t tx,Double_t ty,Double_t tz)">SetCtubDimensions</a>(param[0], param[1], param[2], param[3], param[4], param[5],
                     param[6], param[7], param[8], param[9], param[10]);
   <a href="../TUCNGeoCtub.html#TUCNGeoCtub:ComputeBBox" title="void TUCNGeoCtub::ComputeBBox()">ComputeBBox</a>();
}

<span class="comment">//_____________________________________________________________________________</span>
<a name="QHb4SB"></a><a href="../ListOfTypes.html#Bool_t">Bool_t</a> <a href="../TUCNGeoCtub.html">TUCNGeoCtub</a>::<a href="../TUCNGeoCtub.html#TUCNGeoCtub:GetPointsOnSegments" title="Bool_t TUCNGeoCtub::GetPointsOnSegments(Int_t npoints,Double_t* array)">GetPointsOnSegments</a>(<a href="../ListOfTypes.html#Int_t">Int_t</a> <span class="comment">/*npoints*/</span>, <a href="../ListOfTypes.html#Double_t">Double_t</a> * <span class="comment">/*array*/</span>) <span class="keyword">const</span>
{
<span class="comment">// Fills array with n random points located on the line segments of the shape mesh.</span>
<span class="comment">// The output array must be provided with a length of minimum 3*npoints. Returns</span>
<span class="comment">// <a href="../ListOfTypes.html#bool">true</a> if operation is implemented.</span>
   <span class="keyword">return</span> <a href="../ListOfTypes.html#Bool_t">kFALSE</a>;
}

<span class="comment">//_____________________________________________________________________________</span>
<a name="xKAXGD"></a><span class="keyword">void</span> <a href="../TUCNGeoCtub.html">TUCNGeoCtub</a>::<a href="../TUCNGeoCtub.html#TUCNGeoCtub:SetPoints" title="void TUCNGeoCtub::SetPoints(Double_t* points) or overloads">SetPoints</a>(<a href="../ListOfTypes.html#Double_t">Double_t</a> *points) <span class="keyword">const</span>
{
<span class="comment">// Create mesh points for the cut tube.</span>
   <a href="../ListOfTypes.html#Double_t">Double_t</a> dz;
   <a href="../ListOfTypes.html#Int_t">Int_t</a> j, n;
   <a href="../ListOfTypes.html#Double_t">Double_t</a> phi, phi1, phi2, dphi;
   phi1 = fPhi1;
   phi2 = fPhi2;
   <span class="keyword">if</span> (phi2&lt;phi1) phi2+=360.;
   n = gGeoManager-&gt;GetNsegments()+1;

   dphi = (phi2-phi1)/(n-1);
   dz   = fDz;

   <span class="keyword">if</span> (points) {
      <a href="../ListOfTypes.html#Int_t">Int_t</a> indx = 0;

      <span class="keyword">for</span> (j = 0; j &lt; n; j++) {
         phi = (phi1+j*dphi)*TMath::DegToRad();
         points[indx+6*n] = points[indx] = fRmin * TMath::Cos(phi);
         indx++;
         points[indx+6*n] = points[indx] = fRmin * TMath::Sin(phi);
         indx++;
         points[indx+6*n] = <a href="../TUCNGeoCtub.html#TUCNGeoCtub:GetZcoord" title="Double_t TUCNGeoCtub::GetZcoord(Double_t xc,Double_t yc,Double_t zc)">GetZcoord</a>(points[indx-2], points[indx-1], dz);
         points[indx]     = <a href="../TUCNGeoCtub.html#TUCNGeoCtub:GetZcoord" title="Double_t TUCNGeoCtub::GetZcoord(Double_t xc,Double_t yc,Double_t zc)">GetZcoord</a>(points[indx-2], points[indx-1], -dz);
         indx++;
      }
      <span class="keyword">for</span> (j = 0; j &lt; n; j++) {
         phi = (phi1+j*dphi)*TMath::DegToRad();
         points[indx+6*n] = points[indx] = fRmax * TMath::Cos(phi);
         indx++;
         points[indx+6*n] = points[indx] = fRmax * TMath::Sin(phi);
         indx++;
         points[indx+6*n]= <a href="../TUCNGeoCtub.html#TUCNGeoCtub:GetZcoord" title="Double_t TUCNGeoCtub::GetZcoord(Double_t xc,Double_t yc,Double_t zc)">GetZcoord</a>(points[indx-2], points[indx-1], dz);
         points[indx]    = <a href="../TUCNGeoCtub.html#TUCNGeoCtub:GetZcoord" title="Double_t TUCNGeoCtub::GetZcoord(Double_t xc,Double_t yc,Double_t zc)">GetZcoord</a>(points[indx-2], points[indx-1], -dz);
         indx++;
      }
   }
}

<span class="comment">//_____________________________________________________________________________</span>
<a name="dXjU2C"></a><span class="keyword">void</span> <a href="../TUCNGeoCtub.html">TUCNGeoCtub</a>::<a href="../TUCNGeoCtub.html#TUCNGeoCtub:SetPoints" title="void TUCNGeoCtub::SetPoints(Double_t* points) or overloads">SetPoints</a>(<a href="../ListOfTypes.html#Float_t">Float_t</a> *points) <span class="keyword">const</span>
{
<span class="comment">// Create mesh points for the cut tube.</span>
   <a href="../ListOfTypes.html#Double_t">Double_t</a> dz;
   <a href="../ListOfTypes.html#Int_t">Int_t</a> j, n;
   <a href="../ListOfTypes.html#Double_t">Double_t</a> phi, phi1, phi2, dphi;
   phi1 = fPhi1;
   phi2 = fPhi2;
   <span class="keyword">if</span> (phi2&lt;phi1) phi2+=360.;
   n = gGeoManager-&gt;GetNsegments()+1;

   dphi = (phi2-phi1)/(n-1);
   dz   = fDz;

   <span class="keyword">if</span> (points) {
      <a href="../ListOfTypes.html#Int_t">Int_t</a> indx = 0;

      <span class="keyword">for</span> (j = 0; j &lt; n; j++) {
         phi = (phi1+j*dphi)*TMath::DegToRad();
         points[indx+6*n] = points[indx] = fRmin * TMath::Cos(phi);
         indx++;
         points[indx+6*n] = points[indx] = fRmin * TMath::Sin(phi);
         indx++;
         points[indx+6*n] = <a href="../TUCNGeoCtub.html#TUCNGeoCtub:GetZcoord" title="Double_t TUCNGeoCtub::GetZcoord(Double_t xc,Double_t yc,Double_t zc)">GetZcoord</a>(points[indx-2], points[indx-1], dz);
         points[indx]     = <a href="../TUCNGeoCtub.html#TUCNGeoCtub:GetZcoord" title="Double_t TUCNGeoCtub::GetZcoord(Double_t xc,Double_t yc,Double_t zc)">GetZcoord</a>(points[indx-2], points[indx-1], -dz);
         indx++;
      }
      <span class="keyword">for</span> (j = 0; j &lt; n; j++) {
         phi = (phi1+j*dphi)*TMath::DegToRad();
         points[indx+6*n] = points[indx] = fRmax * TMath::Cos(phi);
         indx++;
         points[indx+6*n] = points[indx] = fRmax * TMath::Sin(phi);
         indx++;
         points[indx+6*n]= <a href="../TUCNGeoCtub.html#TUCNGeoCtub:GetZcoord" title="Double_t TUCNGeoCtub::GetZcoord(Double_t xc,Double_t yc,Double_t zc)">GetZcoord</a>(points[indx-2], points[indx-1], dz);
         points[indx]    = <a href="../TUCNGeoCtub.html#TUCNGeoCtub:GetZcoord" title="Double_t TUCNGeoCtub::GetZcoord(Double_t xc,Double_t yc,Double_t zc)">GetZcoord</a>(points[indx-2], points[indx-1], -dz);
         indx++;
      }
   }
}

<span class="comment">//_____________________________________________________________________________</span>
<a name="p3RbpC"></a><span class="keyword">void</span> <a href="../TUCNGeoCtub.html">TUCNGeoCtub</a>::<a href="../TUCNGeoCtub.html#TUCNGeoCtub:GetMeshNumbers" title="void TUCNGeoCtub::GetMeshNumbers(Int_t&amp; nvert,Int_t&amp; nsegs,Int_t&amp; npols)">GetMeshNumbers</a>(<a href="../ListOfTypes.html#Int_t">Int_t</a> &amp;nvert, <a href="../ListOfTypes.html#Int_t">Int_t</a> &amp;nsegs, <a href="../ListOfTypes.html#Int_t">Int_t</a> &amp;npols) <span class="keyword">const</span>
{
<span class="comment">// Returns numbers of vertices, segments and polygons composing the shape mesh.</span>
   <a href="../TUCNGeoTubeSeg.html">TUCNGeoTubeSeg</a>::<a href="../TUCNGeoTubeSeg.html#TUCNGeoTubeSeg:GetMeshNumbers" title="void TUCNGeoTubeSeg::GetMeshNumbers(Int_t&amp; nvert,Int_t&amp; nsegs,Int_t&amp; npols)">GetMeshNumbers</a>(nvert,nsegs,npols);
}

<span class="comment">//_____________________________________________________________________________</span>
<a name="Qw8qaD"></a><a href="../ListOfTypes.html#Int_t">Int_t</a> <a href="../TUCNGeoCtub.html">TUCNGeoCtub</a>::<a href="../TUCNGeoCtub.html#TUCNGeoCtub:GetNmeshVertices" title="Int_t TUCNGeoCtub::GetNmeshVertices()">GetNmeshVertices</a>() <span class="keyword">const</span>
{
<span class="comment">// Return number of vertices of the mesh representation</span>
   <a href="../ListOfTypes.html#Int_t">Int_t</a> n = gGeoManager-&gt;GetNsegments()+1;
   <a href="../ListOfTypes.html#Int_t">Int_t</a> numPoints = n*4;
   <span class="keyword">return</span> numPoints;
}

<span class="comment">//_____________________________________________________________________________</span>
<a name="G0rmSE"></a><span class="keyword">const</span> TBuffer3D &amp; <a href="../TUCNGeoCtub.html">TUCNGeoCtub</a>::<a href="../TUCNGeoCtub.html#TUCNGeoCtub:GetBuffer3D" title="const TBuffer3D&amp; TUCNGeoCtub::GetBuffer3D(Int_t reqSections,Bool_t localFrame)">GetBuffer3D</a>(<a href="../ListOfTypes.html#Int_t">Int_t</a> reqSections, <a href="../ListOfTypes.html#Bool_t">Bool_t</a> localFrame) <span class="keyword">const</span>
{
<span class="comment">// Fills a static 3D buffer and returns a reference.</span>
   <span class="keyword">static</span> TBuffer3DCutTube buffer;

   <a href="../TUCNGeoBBox.html">TUCNGeoBBox</a>::<a href="../#TGeoBBox:FillBuffer3D" title="void TGeoBBox::FillBuffer3D(TBuffer3D&amp; buffer,Int_t reqSections,Bool_t localFrame)">FillBuffer3D</a>(buffer, reqSections, localFrame);

   <span class="keyword">if</span> (reqSections &amp; TBuffer3D::kShapeSpecific) {
      <span class="comment">// These from TBuffer3DCutTube / <a href="../TUCNGeoCtub.html">TUCNGeoCtub</a></span>
      buffer.fRadiusInner  = fRmin;
      buffer.fRadiusOuter  = fRmax;
      buffer.fHalfLength   = fDz;
      buffer.fPhiMin       = fPhi1;
      buffer.fPhiMax       = fPhi2;

      <span class="keyword">for</span> (<a href="../ListOfTypes.html#UInt_t">UInt_t</a> i = 0; i &lt; 3; i++ ) {
         buffer.fLowPlaneNorm[i] = <a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNlow" title="Double_t TUCNGeoCtub::fNlow">fNlow</a>[i];
         buffer.fHighPlaneNorm[i] = <a href="../TUCNGeoCtub.html#TUCNGeoCtub:fNhigh" title="Double_t TUCNGeoCtub::fNhigh">fNhigh</a>[i];
      }
      buffer.SetSectionsValid(TBuffer3D::kShapeSpecific);
   }
   <span class="keyword">if</span> (reqSections &amp; TBuffer3D::kRawSizes) {
      <a href="../ListOfTypes.html#Int_t">Int_t</a> n = gGeoManager-&gt;GetNsegments()+1;
      <a href="../ListOfTypes.html#Int_t">Int_t</a> nbPnts = 4*n;
      <a href="../ListOfTypes.html#Int_t">Int_t</a> nbSegs = 2*nbPnts;
      <a href="../ListOfTypes.html#Int_t">Int_t</a> nbPols = nbPnts-2;
      <span class="keyword">if</span> (buffer.SetRawSizes(nbPnts, 3*nbPnts, nbSegs, 3*nbSegs, nbPols, 6*nbPols)) {
         buffer.SetSectionsValid(TBuffer3D::kRawSizes);
      }
   }
   <span class="keyword">if</span> ((reqSections &amp; TBuffer3D::kRaw) &amp;&amp; buffer.SectionsValid(TBuffer3D::kRawSizes)) {
      <a href="../TUCNGeoCtub.html#TUCNGeoCtub:SetPoints" title="void TUCNGeoCtub::SetPoints(Double_t* points) or overloads">SetPoints</a>(buffer.fPnts);
      <span class="keyword">if</span> (!buffer.fLocalFrame) {
         <a href="../#TGeoShape:TransformPoints" title="void TGeoShape::TransformPoints(Double_t* points,UInt_t NbPoints)">TransformPoints</a>(buffer.fPnts, buffer.NbPnts());
      }
      <a href="../TUCNGeoTubeSeg.html#TUCNGeoTubeSeg:SetSegsAndPols" title="void TUCNGeoTubeSeg::SetSegsAndPols(TBuffer3D&amp; buff)">SetSegsAndPols</a>(buffer);
      buffer.SetSectionsValid(TBuffer3D::kRaw);
   }

   <span class="keyword">return</span> buffer;
}

</pre>

<br />
<!--SIGNATURE-->

<em>Last change: Thu Jun 18 00:10:42 2009</em><br />
<em>Last generated: 2009-06-18 00:10</em><br />

<hr />
<em>
This page has been automatically generated. If you have any comments or suggestions about the page layout send a mail to <a href="mailto:rootdev@root.cern.ch">ROOT support</a>, or contact <a href="mailto:rootdev@root.cern.ch">the developers</a> with any questions or problems regarding ROOT.
</em>
</body>
</html>
