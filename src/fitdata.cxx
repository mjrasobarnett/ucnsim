/////////////////////////////////////////////////////////////////////////////////
// Program to Read in the Data generated by Simulation and Fit it in ROOT
//
// March 2009, M.Barnett
////////////////////////////////////////////////////////////////////////////////

#ifndef __CINT__

#include <iostream>
#include <fstream>
#include <cassert>

#include "TCanvas.h"
#include "TH1.h"
#include "TH2.h"
#include "TH3.h"
#include "TF1.h"
#include "TStyle.h"
#include "TRint.h"
#include "TMath.h"
#include "TLegend.h"
#include "TGraphErrors.h"

#include "Constants.h"
#include "Units.h"
#include "TUCNDataParser.h"

using namespace Units;
using namespace Constants;


// -- Globals
Double_t total_energy = 200*neV;	
Double_t neutronmass = (neutron_mass_c2/c_squared);

using namespace std;

Double_t poissonf(Double_t*x,Double_t*par);
Double_t densityf(Double_t*x, Double_t*par);

Int_t main(Int_t argc,Char_t **argv)
{
	string filename1;
	string filename2;

	if (argc == 3) {
		filename1 = argv[1];
		filename2 = argv[2];
	} else {
		cerr << "Usage:" << endl;
		cerr << "fitucndata <ucndata-filename> <initialangledata-filename>" << endl;
		return 1;
	}
	
	// --------------------------------------------------------------------------------------
	// Data Collection and Storage
	TUCNDataParser parser;
	parser.LoadFile(filename1);
	
	cout << "1" << endl;
	
	string columntitle1 = "Neutron Time";
	string columntitle2 = "Neutron Energy";
	string columntitle3 = "Neutron Path Length";
	string columntitle4 = "X Position";
	string columntitle5 = "Y Position";
	string columntitle6 = "Z Position";
	string columntitle7 = "PX";
	string columntitle8 = "PY";
	string columntitle9 = "PZ";
	
	vector<string> timedata;
	vector<string> energydata;
	vector<string> pathlengthdata;
	vector<string> xdata;
	vector<string> ydata;
	vector<string> zdata;
	vector<string> pxdata;
	vector<string> pydata;
	vector<string> pzdata;
	
	vector<double> neutrontimes;
	vector<double> neutronenergies;
	vector<double> neutronpathlengths;
	vector<double> neutronx;
	vector<double> neutrony;
	vector<double> neutronz;
	vector<double> neutronpx;
	vector<double> neutronpy;
	vector<double> neutronpz;
		
	parser.GetData(timedata, columntitle1);
	parser.ConvertVectorDouble(timedata, neutrontimes);
	parser.GetData(energydata, columntitle2);
	parser.ConvertVectorDouble(energydata, neutronenergies);
	parser.GetData(pathlengthdata, columntitle3);
	parser.ConvertVectorDouble(pathlengthdata, neutronpathlengths);
	parser.GetData(xdata, columntitle4);
	parser.ConvertVectorDouble(xdata, neutronx);
	parser.GetData(ydata, columntitle5);
	parser.ConvertVectorDouble(ydata, neutrony);
	parser.GetData(zdata, columntitle6);
	parser.ConvertVectorDouble(zdata, neutronz);
	parser.GetData(pxdata, columntitle7);
	parser.ConvertVectorDouble(pxdata, neutronpx);
	parser.GetData(pydata, columntitle8);
	parser.ConvertVectorDouble(pydata, neutronpy);
	parser.GetData(pzdata, columntitle9);
	parser.ConvertVectorDouble(pzdata, neutronpz);

	size_t numberofneutrons = neutrontimes.size();		
	
	TRint *theApp = new TRint("UCN App", &argc, argv);
#else 
Int_t fitucndata() {	

#endif
	
	
	// --------------------------------------------------------------------------------------
	// -- Important Parameters
	Int_t nbins = 50;
	Double_t boxX = 0.2, boxY = 0.2, boxZ = 0.9;
		
	// Fill Histograms
	TH1F * Histogram1a = new TH1F("Histogram1a","Neutron X",nbins,-boxX/2,boxX/2);
	TH1F * Histogram1b = new TH1F("Histogram1b","Neutron Y",nbins,-boxY/2,boxY/2);
	TH1F * Histogram1c = new TH1F("Histogram1c","Neutron Energy",nbins,0.,total_energy/neV);
	//TH1F * Histogram1d = new TH1F("Histogram1d","Neutron Path length",nbins,100,400);
	TH1F * Histogram2a = new TH1F("Histogram2a","Neutron Momentum",nbins,0.0,30);	
	TH1F * Histogram2b = new TH1F("Histogram2b","Neutron Px",nbins,-20.,+20.);	
	TH1F * Histogram2c = new TH1F("Histogram2c","Neutron Py",nbins,-20.,+20.);	
	TH1F * Histogram2d = new TH1F("Histogram2d","Neutron Pz",nbins,-20.,+20.);
	TH1F * Histogram3 = new TH1F("Histogram3a","Neutron Density versus height",nbins,0.0, 2.*boxZ);	
		
		
	for (unsigned int j = 0; j < numberofneutrons; j++) {
		Histogram1a->Fill(neutronx[j]);
		Histogram1b->Fill(neutrony[j]);
		Histogram1c->Fill(neutronenergies[j]);
		//Histogram1d->Fill(neutronpathlengths[j]);
		Histogram2a->Fill(TMath::Sqrt(neutronpx[j]*neutronpx[j] + neutronpy[j]*neutronpy[j] + neutronpz[j]*neutronpz[j]));
		Histogram2b->Fill(neutronpx[j]);
		Histogram2c->Fill(neutronpy[j]);
		Histogram2d->Fill(neutronpz[j]);
		Histogram3->Fill(neutronz[j]);		
	}	
	
	// STYLE ELEMENTS
//	gStyle->SetOptFit(0111); // Sets which things to include in the Fit Box - currently prints chi2, rms and name/value of parameters
//	gStyle->SetPalette(1);
	
	TCanvas * histcanvas1 = new TCanvas("HistCanvas1","Position, Energy, PathLength",0,0,800,800);
	histcanvas1->Divide(2,2);
	histcanvas1->SetGrid();
	
	histcanvas1->cd(1);
	Histogram1a->SetXTitle("X Position");
	Histogram1a->SetYTitle("Neutrons");
	Histogram1a->Draw();
	
	histcanvas1->cd(2);
	Histogram1b->SetXTitle("Y Position");
	Histogram1b->SetYTitle("Neutrons");
	Histogram1b->Draw();
	
	histcanvas1->cd(3);
	Histogram1c->SetXTitle("Energy (neV)");
	Histogram1c->SetYTitle("Neutrons");
	Histogram1c->Draw();
		
	
	// --------------------------------------------------------------------------------------
	TCanvas * histcanvas2 = new TCanvas("HistCanvas2","Momentum",0,0,800,800);
	histcanvas2->Divide(2,2);
	histcanvas2->SetGrid();
	histcanvas2->cd(1);
	
	Histogram2a->SetXTitle("P (eV)");
	Histogram2a->SetYTitle("Number of Neutrons");
	Histogram2a->Draw();
	
	histcanvas2->cd(2);
	Histogram2b->SetXTitle("Px (eV)");
	Histogram2b->SetYTitle("Number of Neutrons");
	Histogram2b->Draw();

	histcanvas2->cd(3);
	Histogram2c->SetXTitle("Py (eV)");
	Histogram2c->SetYTitle("Number of Neutrons");
	Histogram2c->Draw();
	
	histcanvas2->cd(4);
	Histogram2d->SetXTitle("Pz (eV)");
	Histogram2d->SetYTitle("Number of Neutrons");
	Histogram2d->Draw();
	
	// --------------------------------------------------------------------------------------
	// Fit Neutron Density versus Height
	TCanvas * histcanvas3 = new TCanvas("HistCanvas3","Neutron Density versus height",0,0,800,800);
   histcanvas3->Divide(1,2);
	histcanvas3->SetGrid();
	histcanvas3->cd(1);
	
	// -- Max height of neutrons
	Double_t maxheight = total_energy/(neutronmass*grav_acceleration);
	
	// TF1 * theorydensf = new TF1("densityf", densityf,0.0,maxheight,1); 
	// theorydensf->SetParName(0,"Const: Density at bottom of tube at time t");                                                
	// theorydensf->SetParameter(0,10);                                               
	// theorydensf->SetLineColor(kBlue);
	// theorydensf->Draw("same");
		
	TF1 * fitdensf = new TF1("fitdensf", densityf,0.0,maxheight,1); 
	fitdensf->SetParName(0,"Const");                                                
	fitdensf->SetParameter(0,240);                                               
	fitdensf->SetLineColor(kRed);
	
	Histogram3->SetLineColor(kBlack);
	Histogram3->SetXTitle("Height from bottom of Tube (m)");
	Histogram3->SetYTitle("Number of Neutrons");
		
	Histogram3->Fit("fitdensf", "R");
	Histogram3->Draw("E1");

	// -------------------------------------------------------------------------------------- 
	// -- Plot difference between bin content and fitted distribution of above histogram
	histcanvas3->cd(2);	
	Int_t n = nbins;
  	Double_t ex[n], ey[n], x[n], y[n]; 
  	for (Int_t i=1;i<n;i++) { 
		x[i] = Histogram3->GetBinCenter(i); 
		y[i] = Histogram3->GetBinContent(i) - fitdensf->Eval(x[i]);
		ex[i] = 0.;
		ey[i] = Histogram3->GetBinError(i);
	} 
  	// create graph 
  	TGraphErrors*gr1  = new TGraphErrors(n,x,y,ex,ey); 
	gr1->SetTitle("Bin value minus fitted value versus height");
	gr1->Draw("AC*");	
	
	//////////////////
	TCanvas * canvas4 = new TCanvas("Canvas4","Neutron Density versus log(KE/E)",0,0,800,800);
   canvas4->SetGrid();
  	Int_t m = nbins;
	Double_t p[m], q[m]; 
  	for (Int_t i=1; i<m; i++) { 
		p[i] = TMath::Log(Histogram3->GetBinCenter(i)); 
    	q[i] = TMath::Log(Histogram3->GetBinContent(i));
	} 
  	// create graph 
  	TGraph *gr2  = new TGraph(m,p,q); 
	gr2->Draw("AC*");
	
	// Set Up Canvas
//	TCanvas * histcanvas = new TCanvas("HistCanvas1","Neutron Travel Time",0,0,800,800);
//	histcanvas->Divide(2,2);
//	histcanvas->SetFillColor(33);
// histcanvas->SetFrameFillColor(41);
//	histcanvas->SetGrid();


	// -------------------------------------------------------------------------------------- 
	// Plot bounce angle data for one track
	TUCNDataParser parser2;
	parser2.LoadFile("bounceangledata.txt");
	string columntitle10 = "Entering Angle";
	string columntitle11 = "Exiting Angle";
	
	vector<string> bounceangledata1;
	vector<double> bounceneutronangles1;
	vector<string> bounceangledata2;
	vector<double> bounceneutronangles2;
	parser2.GetData(bounceangledata1, columntitle10);
	parser2.ConvertVectorDouble(bounceangledata1, bounceneutronangles1);
	parser2.GetData(bounceangledata2, columntitle11);
	parser2.ConvertVectorDouble(bounceangledata2, bounceneutronangles2);
		
	TH1F * Histogram4a = new TH1F("Histogram4a","Entering Angle",20,0.0,TMath::Pi()/2.0);	
	TH1F * Histogram4b = new TH1F("Histogram4b","Exiting Angle",20,0.0,TMath::Pi()/2.0);	
	cout << bounceneutronangles1.size()	<< "\t" << bounceangledata1.size() << endl;
	for (unsigned int j = 0; j < bounceneutronangles1.size(); j++) {
		cout << bounceneutronangles1[j] << endl;
		Histogram4a->Fill(bounceneutronangles1[j]);
		Histogram4b->Fill(bounceneutronangles2[j]);
		
	}
	TCanvas * canvas5 = new TCanvas("Canvas5","Bounce angles for 1 neutron out of 10000",0,0,800,800);
	canvas5->Divide(1,2);
	canvas5->cd(1);
	Histogram4a->SetXTitle("Theta (initial)");
	Histogram4a->Draw();
	canvas5->cd(2);
	Histogram4b->SetXTitle("Theta (after bounce)");
	Histogram4b->Draw();

	// -------------------------------------------------------------------------------------- 
	// Plot initial angle data
	TUCNDataParser parser3;
	parser3.LoadFile(filename2);
	string columntitle12 = "dx";
	string columntitle13 = "dy";
	string columntitle14 = "dz";
	string columntitle15 = "theta";
	string columntitle16 = "phi";
	
	
	vector<string> angledata1;
	vector<double> neutronangles1;
	vector<string> angledata2;
	vector<double> neutronangles2;
	vector<string> angledata3;
	vector<double> neutronangles3;
	vector<string> angledata4;
	vector<double> neutronangles4;
	vector<string> angledata5;
	vector<double> neutronangles5;
	
	parser3.GetData(angledata1, columntitle12);
	parser3.ConvertVectorDouble(angledata1, neutronangles1);
	parser3.GetData(angledata2, columntitle13);	
	parser3.ConvertVectorDouble(angledata2, neutronangles2);
	parser3.GetData(angledata3, columntitle14);
	parser3.ConvertVectorDouble(angledata3, neutronangles3);
	parser3.GetData(angledata4, columntitle15);	
	parser3.ConvertVectorDouble(angledata4, neutronangles4);
	parser3.GetData(angledata5, columntitle16);	
	parser3.ConvertVectorDouble(angledata5, neutronangles5);
	
	TH3F * Histogram5a = new TH3F("Histogram5a","dx",50,-1.0,1.0, 50,-1.0,1.0, 50,-1.0,1.0);	
	TH1F * Histogram5c = new TH1F("Histogram5c","phi", 100,0.0,TMath::Pi()*2);	
	TH1F * Histogram5d = new TH1F("Histogram5d","theta",100,0.0,TMath::Pi());	

	for (unsigned int j = 0; j < neutronangles3.size(); j++) {
//		cout << neutronangles1[j] << "\t" << neutronangles2[j] << "\t" << neutronangles3[j] << "\t" << neutronangles4[j] << endl;
		Histogram5a->Fill(neutronangles1[j], neutronangles2[j], neutronangles3[j]);
		Histogram5c->Fill(neutronangles5[j]);
		Histogram5d->Fill(neutronangles4[j]);

	}
	TCanvas * canvas6 = new TCanvas("Canvas6","Initial Direction Distribution",0,0,800,800);
	canvas6->cd(1);
	Histogram5a->SetXTitle("X");
	Histogram5a->SetYTitle("Y");
	Histogram5a->SetZTitle("Z");
	Histogram5a->Draw("");
	
	TCanvas * canvas7 = new TCanvas("Canvas7","Initial Angle Distributions",0,0,800,800);
	canvas7->Divide(1,2);
	canvas7->cd(1);
	Histogram5c->SetXTitle("Phi");
	Histogram5c->Draw("");
	canvas7->cd(2);
	Histogram5d->SetXTitle("Theta");
	Histogram5d->Draw("");
	
	// --------------------------------------------------------------------------------------
	// Fit Neutron Travel Time	

//	histcanvas->cd(1);
/*	Double_t h1par[7];
	TF1 *h1f1  = new TF1("h1f1","gaus",1.0,1.3);
	TF1 *h1f2  = new TF1("h1f2","expo",3,10);
	TF1 *h1f3  = new TF1("h1f3", "expo", 1.4, 2);
	TF1 *h1total = new TF1("h1total","gaus(0)+expo(3)+expo(5)",1.0,10);
	h1f1->SetLineColor(kBlue);
	h1f2->SetLineColor(kBlue);
	h1f3->SetLineColor(kBlue);
	h1total->SetLineColor(kRed);

	Histogram1->SetLineColor(kBlack);
	Histogram1->SetXTitle("Travel Time (s)");
	Histogram1->SetYTitle("Number of Neutrons");

	Histogram1->Fit(h1f1, "R");
	Histogram1->Fit(h1f2, "R+");
	Histogram1->Fit(h1f3, "R+");

	h1f1->GetParameters(&h1par[0]);
	h1f2->GetParameters(&h1par[3]);
   h1f3->GetParameters(&h1par[5]);

	h1total->SetParameters(h1par);
	Histogram1->Fit(h1total,"R+");

	//	TF1 pois1("pois1",poissonf,0,20,2); 
	//	pois1.SetParName(0,"Const");                                                
	//	pois1.SetParName(1,"mu");                                                  
	//	pois1.SetParameter(0,40); //                                               
	//	pois1.SetParameter(1,5); //
	//	Histogram1->Fit("pois1", "R");
*/
	// --------------------------------------------------------------------------------------
	// Fit Neutron Energy
//	histcanvas->cd(2);

/*	TCanvas * histcanvas2 = new TCanvas("HistCanvas2","Energy (neV)",0,0,800,800);
	histcanvas2->SetFillColor(33);
   //histcanvas2->SetFrameFillColor(41);
	histcanvas2->SetGrid();
	Histogram2->SetLineColor(1);
	Histogram2->SetXTitle("Energy (neV)");
	Histogram2->SetYTitle("Number of Neutrons");
//	Histogram2->Fit("gaus");
	Histogram2->Draw();
*/	
	// --------------------------------------------------------------------------------------
	// 
//	histcanvas->cd(3);
/*	TCanvas * histcanvas3 = new TCanvas("HistCanvas3","Path Length",0,0,800,800);
	histcanvas3->SetFillColor(33);
   //histcanvas3->SetFrameFillColor(41);
	histcanvas3->SetGrid();
	Histogram2->SetLineColor(2);
	Histogram3->SetXTitle("Path Length (m)");
	Histogram3->SetYTitle("Number of Neutrons");
	Histogram3->Draw();
*/	
// --------------------------------------------------------------------------------------
	
	
#ifndef __CINT__
	theApp->Run();
#endif
	return 0;
}

Double_t poissonf(Double_t*x,Double_t*par)                                         
{                                                                              
  return par[0]*TMath::Poisson(x[0],par[1]);
}

Double_t densityf(Double_t*x, Double_t*par)
{
	Double_t value = (total_energy - neutronmass*grav_acceleration*x[0])/total_energy;
	assert(value >= 0.0);
	return par[0]*sqrt(value);
}




